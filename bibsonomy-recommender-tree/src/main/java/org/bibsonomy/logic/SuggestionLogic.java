package org.bibsonomy.logic;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.bibsonomy.common.Pair;
import org.bibsonomy.model.SuggestTree;
import org.bibsonomy.model.SuggestTree.Node;
import org.springframework.beans.factory.InitializingBean;


/**
 * TitleSuggestionLogic provides the data for the post autocompletion.
 * 
 * @author nilsraabe
 *
 */

public class SuggestionLogic implements InitializingBean {
	
	private static final Log log 	= LogFactory.getLog(SuggestionLogic.class);
	
	private static final int TOP_K 	= 20; // TODO: how many?

	private SuggestTree publicationTree;
	private SuggestTree bookmarkTree;
	
	private String sourceFilePath;
		
	@Override
	public void afterPropertiesSet() throws Exception {
		publicationTree = buildTree("publication");
		bookmarkTree = buildTree("bookmark");
	}
	
	/**
	 * Setup the suggest tree.
	 * 
	 * Attention:
	 * The path in project.properties (titleSuggestion.sourceFilePath) must be set correctly.
	 * 
	 * @param file
	 * 		name of the source file (source file should be in the titleSuggestion.sourceFilePath folder)
	 * @return
	 * 		returns the prepared suggest tree
	 */
	private SuggestTree buildTree(String file) {
		
		log.info("building " + file + " tree");
		
		final SuggestTree tree = new SuggestTree(TOP_K);
		
		File tempFile = new File(sourceFilePath + "/" + file + "_title.txt");
		
		if(!tempFile.exists()) {
			log.warn("Source File '" + file + "_title.txt" + "' NOT found in path : " + sourceFilePath + "/  - Cannot build tree !");
		} else {
			
			try {
				final BufferedReader publicationReader = new BufferedReader(new FileReader(sourceFilePath + "/" + file + "_title.txt"));
				String title = null;
				
				while ((title = publicationReader.readLine()) != null) {

					//TODO rating is almost nonexistent in live system
					
					int rating = Integer.parseInt(publicationReader.readLine());
					
					tree.put(title, rating);
				}
				
				publicationReader.close();
				
			} catch (IOException e) {
				log.error("error while reading publication titles for suggestion tree", e);
			}
			
			log.info("finished building " + file + " tree done.");
		}
		
		return tree;
	}

	
	/**
	 * Get all publication suggestions to a given prefix.
	 * 
	 * @param prefix
	 * 		  The user input whereupon the autocompletion recommends.
	 * @return
	 * 		  A list of pairs whereby the String represents the recommendation and the Integer the rating.
	 */
	public List<Pair<String, Integer>> getPublicationSuggestion(String prefix) {
		return getSuggestion(this.publicationTree, prefix);
	}


	private List<Pair<String, Integer>> getSuggestion(final SuggestTree tree, String prefix) {
		
		final Node node = tree.getSuggestions(prefix);		
		final List<Pair<String, Integer>> suggestion = new LinkedList<Pair<String, Integer>>();
		
		if (node == null) {
			return suggestion;
		}
		
		for (int i = 0; i < node.size(); i++) {
			suggestion.add(new Pair<String, Integer>(node.getSuggestion(i), node.getWeight(i)));
		}
		
		return suggestion;
	}
	
	/**
	 * Get all bookmark suggestions to a given prefix.
	 * 
	 * @param prefix
	 * 		  The user input whereupon the autocompletion recommends.
	 * @return
	 * 		  A list of pairs whereby the String represents the recommendation and the Integer the rating.
	 */
	public List<Pair<String, Integer>> getBookmarkSuggestion(String prefix) {
		return getSuggestion(this.bookmarkTree, prefix);
	}
	
	/**
	 * Get all publication and bookmark suggestions to a given prefix.
	 * 
	 * @param prefix
	 * 		  The user input whereupon the autocompletion recommends.
	 * @return
	 * 		  A list of pairs whereby the String represents the recommendation and the Integer the rating.
	 */
	public List<Pair<String, Integer>> getPostSuggestion(final String prefix) {
		final List<Pair<String, Integer>> suggestion = new LinkedList<Pair<String,Integer>>();
		
		suggestion.addAll(this.getPublicationSuggestion(prefix));
		suggestion.addAll(this.getBookmarkSuggestion(prefix));
		
		Collections.sort(suggestion, new PairComperator());
		
		return suggestion;
	}
	
	/**
	 * Set the location whereby the .txt files of publication and bookmark titles are.
	 * (BTW: Text Files are generated by the file batch_suggestion_title.java)
	 * 
	 * @param sourceFilePath the titlePath to set
	 */
	public void setSourceFilePath(String sourceFilePath) {
		this.sourceFilePath = sourceFilePath;
	}

	
}

/**
 * Comperator class to compare the suggestions against the user rating 
 */
class PairComperator implements Comparator<Pair<String, Integer>>{
	 
	@Override
	public int compare(Pair<String, Integer> o1, Pair<String, Integer> o2) {
		if(o1.getSecond().compareTo(o2.getSecond()) < 0) {
			return -1;
		}
		
		if(o1.getSecond().compareTo(o2.getSecond()) > 0) {
			return 1;
		}
		
		return System.identityHashCode(o1.getFirst()) - System.identityHashCode(o2.getFirst());
	}
} 
