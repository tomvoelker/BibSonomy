package org.bibsonomy.search.es.management.post;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;

import org.bibsonomy.common.JobResult;
import org.bibsonomy.common.enums.Status;
import org.bibsonomy.database.managers.AdminDatabaseManager;
import org.bibsonomy.database.managers.BibTexDatabaseManager;
import org.bibsonomy.database.managers.GoldStandardPublicationDatabaseManager;
import org.bibsonomy.database.managers.PersonDatabaseManager;
import org.bibsonomy.database.services.query.PostSearchQuery;
import org.bibsonomy.model.BibTex;
import org.bibsonomy.model.GoldStandardPublication;
import org.bibsonomy.model.Person;
import org.bibsonomy.model.PersonName;
import org.bibsonomy.model.Post;
import org.bibsonomy.model.ResourcePersonRelation;
import org.bibsonomy.model.ResultList;
import org.bibsonomy.model.Tag;
import org.bibsonomy.model.User;
import org.bibsonomy.model.factories.ResourceFactory;
import org.bibsonomy.model.util.BibTexUtils;
import org.bibsonomy.model.util.GroupUtils;
import org.bibsonomy.search.es.EsSpringContextWrapper;
import org.bibsonomy.search.es.search.post.ElasticsearchPostSearch;
import org.bibsonomy.search.es.testutil.AbstractCommunityPostSearchTest;
import org.bibsonomy.util.Sets;
import org.junit.Test;

import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;

/**
 * tests for the {@link ElasticsearchCommunityPostManager} of the publication entries
 *
 * @author dzo
 */
public class ElasticsearchCommunityPostPublicationManagerITCase extends AbstractCommunityPostSearchTest<GoldStandardPublication> {

	private static final ElasticsearchPostSearch<GoldStandardPublication> COMMUNITY_PUBLICATION_SEARCH = EsSpringContextWrapper.getContext().getBean("elasticsearchCommunityPublicationSearch", ElasticsearchPostSearch.class);

	private static final ElasticsearchCommunityPostManager<GoldStandardPublication> MANAGER = EsSpringContextWrapper.getContext().getBean("elasticsearchCommunityPublicationManager", ElasticsearchCommunityPostManager.class);

	/** some db managers to insert and delete data */
	private static final GoldStandardPublicationDatabaseManager GOLD_STANDARD_PUBLICATION_DATABASE_MANAGER = testDatabaseContext.getBean(GoldStandardPublicationDatabaseManager.class);
	private static final BibTexDatabaseManager PUBLICATION_DATABASE_MANAGER = testDatabaseContext.getBean(BibTexDatabaseManager.class);
	private static final AdminDatabaseManager ADMIN_DATABASE_MANAGER = testDatabaseContext.getBean(AdminDatabaseManager.class);
	private static final PersonDatabaseManager PERSON_DATABASE_MANAGER = testDatabaseContext.getBean(PersonDatabaseManager.class);

	/** some test constants TODO: move */
	private static final User LOGGEDIN_USER = new User("testuser1");
	private static final User anonymUser = new User();

	// TODO: move
	public static PostSearchQuery<?> buildQuery(final String searchTerms) {
		final PostSearchQuery<?> query = new PostSearchQuery<>();
		query.setSearch(searchTerms);
		return query;
	}

	@Test
	public void testGenerate() {
		// the indices are generated by the abstract class

		final PostSearchQuery<GoldStandardPublication> query = new PostSearchQuery<>();
		query.setSearch("test title");

		// check if gold standard publications are indexed
		final List<Post<GoldStandardPublication>> communityResults = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);
		assertThat(communityResults.size(), is(10));

		// check if also normal posts are indexed
		query.setSearch("ontologies");
		final ResultList<Post<GoldStandardPublication>> normalPosts = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);
		assertThat(normalPosts.size(), is(1));
		assertThat(normalPosts.getTotalCount(), is(1));

		final Post<GoldStandardPublication> firstResult = normalPosts.get(0);
		assertThat(firstResult.getResource().getTitle(), is("A case for abductive reasoning over ontologies"));
	}

	@Test
	public void testUpdate() {
		final String testuser1 = "testuser1";
		final User loggedinUser = new User(testuser1);
		final PostSearchQuery<?> query = buildQuery("Wurst aufs Brot");
		final List<Post<GoldStandardPublication>> communityPosts = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);

		assertThat(communityPosts.size(), is(1));

		final Post<GoldStandardPublication> goldStandardPublicationPost = communityPosts.get(0);
		final GoldStandardPublication publication = goldStandardPublicationPost.getResource();
		final String interHash = publication.getInterHash();
		final String intraHash = publication.getIntraHash();


		final boolean deleted = GOLD_STANDARD_PUBLICATION_DATABASE_MANAGER.deletePost("", interHash, loggedinUser, this.dbSession);
		assertThat(deleted, is(true));

		this.updateIndex();

		final List<Post<GoldStandardPublication>> afterCommunityDelete = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);

		// deleting the community post should do nothing, if at least one user has the publication in his/her collection
		assertThat(afterCommunityDelete.size(), is(1));

		final boolean userPostDeleted = PUBLICATION_DATABASE_MANAGER.deletePost("testuserP", intraHash, loggedinUser, this.dbSession);
		assertThat(userPostDeleted, is(true));

		this.updateIndex();

		final List<Post<GoldStandardPublication>> afterNormalPostDelete = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);

		assertThat(afterNormalPostDelete.size(), is(0));

		/*
		 * insert a new publication
		 */
		final Post<BibTex> publicationPost = generateTestPost(BibTex.class);
		publicationPost.setUser(loggedinUser);
		final JobResult jobResult = PUBLICATION_DATABASE_MANAGER.createPost(publicationPost, loggedinUser, this.dbSession);

		assertThat(jobResult.getStatus(), is(Status.OK));

		this.updateIndex();

		final PostSearchQuery<?> query2 = buildQuery(publicationPost.getResource().getTitle());

		final List<Post<GoldStandardPublication>> postsAfterCreating = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query2);

		assertThat(postsAfterCreating.size(), is(1));

		/*
		 * insert a new communitypost
		 */
		final Post<GoldStandardPublication> newGoldstandardPost = generateTestPost(GoldStandardPublication.class);
		final String publicationAbstract = "abstract";
		newGoldstandardPost.getResource().setAbstract(publicationAbstract);

		GOLD_STANDARD_PUBLICATION_DATABASE_MANAGER.createPost(newGoldstandardPost, loggedinUser, this.dbSession);

		this.updateIndex();

		final ResultList<Post<GoldStandardPublication>> postsAfterCommunityCreating = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query2);

		assertThat(postsAfterCommunityCreating.size(), is(1));
		assertThat(postsAfterCommunityCreating.get(0).getResource().getAbstract(), is(publicationAbstract));
		final PostSearchQuery<?> query3 = buildQuery("\"test friend title\"");
		final ResultList<Post<GoldStandardPublication>> testuser3PostsInIndex = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query3);

		assertThat(testuser3PostsInIndex.size(), is(1));

		// mark user as spammer
		final String userToFlag = "testuser3";
		final User user = new User(userToFlag);
		user.setSpammer(Boolean.TRUE);
		user.setAlgorithm("unittest");
		ADMIN_DATABASE_MANAGER.flagSpammer(user, "admin", this.dbSession);

		this.updateIndex();

		final ResultList<Post<GoldStandardPublication>> testuser3PostsInIndexAfterMarkedAsSpammer = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query3);

		assertThat(testuser3PostsInIndexAfterMarkedAsSpammer.size(), is(0));

		// unmark a user
		user.setSpammer(Boolean.FALSE);
		user.setAlgorithm("admin");
		user.setPrediction(null); // FIXME: side effects :(
		ADMIN_DATABASE_MANAGER.flagSpammer(user, "admin", this.dbSession);

		this.updateIndex();

		final ResultList<Post<GoldStandardPublication>> testuser3PostsInIndexAfterUnmarkedAsSpammer = COMMUNITY_PUBLICATION_SEARCH.getPosts(new User(userToFlag), query3);

		assertThat(testuser3PostsInIndexAfterUnmarkedAsSpammer.size(), is(1));

		final Post<GoldStandardPublication> firstResultTestuser3 = testuser3PostsInIndexAfterUnmarkedAsSpammer.get(0);

		final List<User> users = firstResultTestuser3.getUsers();
		assertThat(users.size(), is(1));

		final ResultList<Post<GoldStandardPublication>> beforeDeleteTestuser1 = COMMUNITY_PUBLICATION_SEARCH.getPosts(loggedinUser, query2);

		assertThat(beforeDeleteTestuser1.size(), is(1));
		assertThat(beforeDeleteTestuser1.get(0).getUsers().size(), is(1));

		final String normalPostHashToDelete = "6ce5d533a44887f2d2730fe7866f8fd0";

		final Post<BibTex> normalPublicationPost = PUBLICATION_DATABASE_MANAGER.getPostDetails(testuser1, normalPostHashToDelete, testuser1, Collections.emptyList(), this.dbSession);
		final boolean deletedNormalPost = PUBLICATION_DATABASE_MANAGER.deletePost(testuser1, normalPostHashToDelete, loggedinUser, this.dbSession);
		assertThat(deletedNormalPost, is(true));

		this.updateIndex();

		final ResultList<Post<GoldStandardPublication>> afterDeleteTestuser1 = COMMUNITY_PUBLICATION_SEARCH.getPosts(loggedinUser, query2);

		assertThat(afterDeleteTestuser1.size(), is(1));
		assertThat(afterDeleteTestuser1.get(0).getUsers().size(), is(0));

		final JobResult normalPostReaddedJobResult = PUBLICATION_DATABASE_MANAGER.createPost(normalPublicationPost, loggedinUser, this.dbSession);
		assertThat(normalPostReaddedJobResult.getStatus(), is(Status.OK));

		this.updateIndex();

		final ResultList<Post<GoldStandardPublication>> afterReaddedTestuser1 = COMMUNITY_PUBLICATION_SEARCH.getPosts(loggedinUser, query2);
		assertThat(afterReaddedTestuser1.get(0).getUsers().size(), is(1));
	}

	@Test
	public void testUpdatePersonResourceRelation() {
		final String interhash = "0c000000d00000f00cef0c00f000e00a";
		final List<ResourcePersonRelation> relations = PERSON_DATABASE_MANAGER.getResourcePersonRelationsWithPersonsByInterhash(interhash, this.dbSession);

		assertThat(relations.size(), is(1));

		final ResourcePersonRelation firstRelation = relations.get(0);

		final PostSearchQuery<?> query = new PostSearchQuery<>();
		query.setPersonNames(Collections.singletonList(new PersonName("Test", "Willi")));
		query.setOnlyIncludeAuthorsWithoutPersonId(true);

		final ResultList<Post<GoldStandardPublication>> postsBeforeDelete = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);
		assertThat(postsBeforeDelete.size(), is(0));

		PERSON_DATABASE_MANAGER.removeResourceRelation(firstRelation.getPerson().getPersonId(), interhash, firstRelation.getPersonIndex(), firstRelation.getRelationType(), LOGGEDIN_USER, this.dbSession);

		this.updateIndex();

		// after the relation is deleted there should be one post with the specified author and without assigned to a person
		final ResultList<Post<GoldStandardPublication>> posts = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);
		assertThat(posts.size(), is(1));

		firstRelation.setPost(GOLD_STANDARD_PUBLICATION_DATABASE_MANAGER.getPostDetails("", interhash, "", Collections.emptyList(), this.dbSession));
		firstRelation.setChangedAt(new Date()); // set new date
		PERSON_DATABASE_MANAGER.addResourceRelation(firstRelation, LOGGEDIN_USER, this.dbSession);

		this.updateIndex();

		final ResultList<Post<GoldStandardPublication>> postsAfterReadd = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);
		assertThat(postsAfterReadd.size(), is(0));
	}

	@Test
	public void testGetPostsByCollegeFilter() {
		final PostSearchQuery<?> query = new PostSearchQuery<>();
		final String college = "Test College";
		query.setCollege(college);

		final ResultList<Post<GoldStandardPublication>> posts = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);
		final int numberOfPostsForTestCollege = 8;
		assertThat(posts.size(), is(numberOfPostsForTestCollege));

		final Person person = PERSON_DATABASE_MANAGER.getPersonById("w.test.4", this.dbSession);
		person.setCollege(college);
		PERSON_DATABASE_MANAGER.updateCollege(person, this.dbSession);

		this.updateIndex();

		final ResultList<Post<GoldStandardPublication>> afterUpdate = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);
		assertThat(afterUpdate.size(), is(numberOfPostsForTestCollege + 1));
	}

	@Test
	public void testSearchInDifferentFields() {
		final Post<GoldStandardPublication> goldStandardPublicationPost = generateTestPost(GoldStandardPublication.class);
		GOLD_STANDARD_PUBLICATION_DATABASE_MANAGER.createPost(goldStandardPublicationPost, anonymUser, this.dbSession);

		this.updateIndex();

		final GoldStandardPublication resource = goldStandardPublicationPost.getResource();
		final PostSearchQuery<?> query = buildQuery(resource.getTitle() + " " + resource.getAuthor().get(0).getLastName());

		final ResultList<Post<GoldStandardPublication>> posts = COMMUNITY_PUBLICATION_SEARCH.getPosts(anonymUser, query);
		assertThat(posts.size(), is(1));
	}

	private static <P extends BibTex> Post<P> generateTestPost(final Class<? extends P> clazz) {
		final Post<P> publicationPost = new Post<>();
		final ResourceFactory factory = new ResourceFactory();
		final P publication = factory.createPublication(clazz);
		publicationPost.setTags(Sets.asSet(new Tag("test")));
		publicationPost.setGroups(Sets.asSet(GroupUtils.buildPublicGroup()));
		publication.setYear("2018");
		publication.setTitle("Firefly");
		publication.setBibtexKey(BibTexUtils.generateBibtexKey(publication));
		publication.setAuthor(Arrays.asList(new PersonName("Book", "Shepherd")));
		publication.setEntrytype(BibTexUtils.ARTICLE);
		publication.recalculateHashes();
		publicationPost.setResource(publication);
		final Date date = new Date();
		publicationPost.setDate(date);
		publicationPost.setChangeDate(date);
		return publicationPost;
	}

	@Override
	protected ElasticsearchCommunityPostManager<GoldStandardPublication> getManager() {
		return MANAGER;
	}
}