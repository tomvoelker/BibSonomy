package de.unikassel.puma.openaccess.sherparomeo;

import static org.bibsonomy.util.ValidationUtils.present;

import java.net.URL;
import java.util.List;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.bibsonomy.util.UrlUtils;

import de.unikassel.puma.openaccess.sherparomeo.model.Condition;
import de.unikassel.puma.openaccess.sherparomeo.model.Publisher;
import de.unikassel.puma.openaccess.sherparomeo.model.Romeoapi;

/**
 * TODO: working but ugly code.
 * TODO: the complete model is generated by jaxb integrate it with the jaxb maven plugin
 * 
 * @author rja
 */
public class SherpaRomeoImpl implements SherpaRomeoInterface {
	private static final Log log = LogFactory.getLog(SherpaRomeoImpl.class);

	private static final String SHERPA_API_URL = "http://www.sherpa.ac.uk/romeo/api24.php";
	
	private JAXBContext context;
	
	/**
	 * default constructor
	 * loads the jaxb context
	 */
	public SherpaRomeoImpl() {
		try {
			this.context = JAXBContext.newInstance(Condition.class.getPackage().getName());
		} catch (final JAXBException e) {
			log.error("error while loading JAXB context", e);
		}
	}

	@Override
	public String getPolicyForPublisher(final String publisher, final String qtype) {
		try {
			String url = SHERPA_API_URL + "?pub=" + UrlUtils.safeURIEncode(publisher);
			if (present(qtype)) {
				url += "&qtype=" + UrlUtils.safeURIEncode(qtype);
			}

			return this.doRequest(new URL(url));
		} catch (final Exception e) {
			log.error("error while getting policy for publisher", e);
		}
		return null;
	}

	@Override
	public String getPolicyForJournal(final String jtitle, final String qtype) {
		try {
			String url = SHERPA_API_URL + "?jtitle=" + UrlUtils.safeURIEncode(jtitle);
			if (present(qtype)) {
				url += "&qtype=" + UrlUtils.safeURIEncode(qtype);
			}

			return this.doRequest(new URL(url));
		} catch (final Exception e) {
			log.error("error while getting policy for journal", e);
		}
		return null;
	}

	/**
	 * Sending request to sherparomeo.
	 * 
	 * FIXME: conditions for pre-/postprints missing
	 * FIXME: shouldn't the webapp convert the model into json?
	 * @param url
	 * @return json formated publishers
	 */
	private String doRequest(final URL url) {
		try {
			final Unmarshaller unmarshaller = this.context.createUnmarshaller();
			final Romeoapi rp = (Romeoapi) unmarshaller.unmarshal(url);
			return this.extractInformations(rp);
		} catch (final JAXBException e) {
			log.error("error unmarshalling response", e);
		}
		return "";
	}

	protected String extractInformations(final Romeoapi rp) {
		final List<Publisher> publishers = rp.getPublishers().getPublisher();
		final JSONObject result = new JSONObject();
		final JSONArray publishersJson = new JSONArray();
		for (final Publisher publisher : publishers) {
			final JSONObject publisherJson = new JSONObject();
			publisherJson.put("name", publisher.getName());
			publisherJson.put("colour", publisher.getRomeocolour());
			
			publisherJson.put("conditions", renderConditions(publisher.getConditions().getCondition()));
			publishersJson.add(publisherJson);
		}
		result.put("publishers", publishersJson);
		return result.toString();
	}

	private static JSONArray renderConditions(final List<Condition> conditions) {
		final JSONArray conditionsJson = new JSONArray();
		for (final Condition condition : conditions) {
			conditionsJson.add(condition.getvalue());
		}
		return conditionsJson;
	}
}
