<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sqlMap PUBLIC "-//iBATIS.com//DTD SQL Map 2.0//EN" "http://www.ibatis.com/dtd/sql-map-2.dtd">

<sqlMap namespace="Common">
<resultMap id="resource" class="resource">
     	<result property="interHash"   column="interHash"       javaType="string" />
     	<result property="intraHash"   column="intraHash"       javaType="string" />     	
		<result property="count"       column="count"                 javaType="int" />
	</resultMap>

	<resultMap id="posts" class="post" groupBy="contentId">
		<result property="contentId"   column="content_id"       javaType="int" />
		<result property="tags"        resultMap="Common.tag" />
		<result property="date"        column="date"             javaType="date" />
		<result property="groups"      resultMap="Common.group" />
		<result property="user"        resultMap="Common.user" ></result>
	</resultMap>

	<resultMap id="group" class="group">
		<result property="groupId" column="group" javaType="int" />
		<result property="name" column="group_name" javaType="string" />
	</resultMap>

	<resultMap id="user" class="user">
		<result property="name" column="user_name" javaType="string" />
	</resultMap>

	<resultMap id="tag" class="tag">
		<result property="name" column="tag_name" javaType="string" />
	</resultMap>

	<!-- Should be used in conjunction with tagWhereQuery. -->
	<sql id="tagFromQuery">
		<iterate property="tagIndex" conjunction=",">
		  tas t$tagIndex[].index$
		</iterate>
	</sql>

	<!--
	   Should be used in conjunction with tagFromQuery.

	   Depending on the number of tags it creates a query like:
	        t1.tag_name = 'some-tag'
	    AND t2.tag_name = 'a-tag'
	    AND t3.tag_name = 'another-tag'
	    AND t1.content_id = t2.content_id
	    AND t2.content_id = t3.content_id
	-->
	<sql id="tagWhereQuery">
		<iterate property="tagIndex" conjunction="AND">
		  <isEqual property="caseSensitiveTagNames" compareValue="true">
		    t$tagIndex[].index$.tag_name = #tagIndex[].tagName#
		  </isEqual>
		  <isEqual property="caseSensitiveTagNames" compareValue="false">
		    t$tagIndex[].index$.tag_lower = lower(#tagIndex[].tagName#)
		  </isEqual>
		</iterate>
		<!-- Self-Join -->
		<iterate property="tagIndex" prepend="AND" conjunction="AND">
		  <isLessThan property="tagIndex[].index" compareProperty="maxTagIndex">
		    t$tagIndex[].index$.content_id = t$tagIndex[].index2$.content_id
		  </isLessThan>
		</iterate>
	</sql>

	<!-- Should be used in conjunction with "conceptWhereQuery". -->
	<sql id="conceptFromQuery">
		<iterate property="tagIndex" conjunction=",">
		  tas t$tagIndex[].index$, 
		  <isEqual property="caseSensitiveTagNames" compareValue="true">
		    (SELECT lower
		     FROM tagtagrelations t$tagIndex[].index$
		     WHERE user_name = #requestedUserName#
		           AND upper = #tagIndex[].tagName#
		     UNION
		     SELECT #tagIndex[].tagName# AS lower
		    ) AS r$tagIndex[].index$
		  </isEqual>
		  <isEqual property="caseSensitiveTagNames" compareValue="false">
		    (SELECT lcase(lower) AS lower
		     FROM tagtagrelations t$tagIndex[].index$
		     WHERE user_name = #requestedUserName#
		           AND lcase(upper) = lcase(#tagIndex[].tagName#)
		     UNION
		     SELECT lcase(#tagIndex[].tagName#) AS lower
		    ) AS r$tagIndex[].index$
		  </isEqual>
		</iterate>
	</sql>

	<!--
	   Should be used in conjunction with conceptFromQuery.
	-->
	<sql id="conceptWhereQuery">
		<iterate property="tagIndex" conjunction="AND">
		  <isEqual property="caseSensitiveTagNames" compareValue="true">
		    t$tagIndex[].index$.tag_name = r$tagIndex[].index$.lower
		  </isEqual>
		  <isEqual property="caseSensitiveTagNames" compareValue="false">
		    t$tagIndex[].index$.tag_lower = r$tagIndex[].index$.lower
		  </isEqual>
		</iterate>
		<!-- Self-Join -->
		<iterate property="tagIndex" prepend="AND" conjunction="AND">
		  <isLessThan property="tagIndex[].index" compareProperty="maxTagIndex">
		    t$tagIndex[].index$.content_id = t$tagIndex[].index2$.content_id
		  </isLessThan>
		</iterate>
	</sql>
    
	<!-- Refactor b to t1, and delete this snippet -->
	<sql id="inGroups">
		<isNotEqual property="userName" compareProperty="requestedUserName" prepend="AND">
		  b.group in (0
		  <iterate property="groups" conjunction="," prepend=",">
		    $groups[]$
		  </iterate>)
		</isNotEqual>
	</sql>
    
	<sql id="inGroups2">
		<isNotEqual property="userName" compareProperty="requestedUserName" prepend="AND">
		  t1.group in (0
		  <iterate property="groups" conjunction="," prepend=",">
		    $groups[]$
		  </iterate>)
		</isNotEqual>
	</sql>

	<!--
	   This query is used for get*ForGroupByTag
	   It selects all content ids (for the specific content type)
		- from all users of the group, if userName is allowed to see them
		- from users of group, if userName is friend of one of the users
		- from userName, if in the group
	-->
	<sql id="selectContentIDs">
		((SELECT t1.content_id, t1.date             <!-- items from users of group which currUser may see -->
		  FROM groups g, <include refid="tagFromQuery"/>
		  WHERE <include refid="tagWhereQuery"/>
		        AND g.group = #groupId#
		        AND g.user_name = t1.user_name      <!-- user owns this item -->
		        <include refid="inGroups2"/>
		        AND t1.content_type = #contentType#
		 )UNION(
		  SELECT t1.content_id, t1.date             <!-- items from users of group which have currUser as friend -->
		  FROM groups g, friends f, <include refid="tagFromQuery"/>
		  WHERE <include refid="tagWhereQuery"/>
		        AND g.group = #groupId#
		        AND f.f_user_name = #userName#      <!-- currUser is friend -->
		        AND g.user_name = f.user_name       <!-- user is in group -->
		        AND t1.user_name = f.user_name      <!-- user owns this item -->              
		        AND t1.group = $groupType$          <!-- item is only for friends -->
		        AND t1.content_type = #contentType#
		 )UNION(
		  SELECT t1.content_id, t1.date             <!-- currUsers items, ... -->
		  FROM groups g, <include refid="tagFromQuery"/>
		  WHERE <include refid="tagWhereQuery"/>
		        AND g.group = #groupId#             <!-- if in this group ... -->
		        AND g.user_name = t1.user_name      <!-- is currUser -->
		        AND t1.user_name = #userName#
		        AND t1.content_type = #contentType#
		 )
		ORDER BY date DESC
		LIMIT #limit# OFFSET #offset#) AS bb
	</sql>

	<!-- This query is used for get*ForUser* -->
	<sql id="getPostForUser">
		<isEqual property="groupId" compareValue="-1">
		  <include refid="inGroups"/>
		</isEqual>
		<isGreaterThan property="groupId" compareValue="-1" prepend="AND">
		  b.group = #groupId#
		</isGreaterThan>
	</sql>

	<sql id="getPostForUser2">
		<isEqual property="groupId" compareValue="-1">
		  <include refid="inGroups2"/>
		</isEqual>
		<isGreaterThan property="groupId" compareValue="-1" prepend="AND">
		  t1.group = #groupId#
		</isGreaterThan>
	</sql>
</sqlMap>