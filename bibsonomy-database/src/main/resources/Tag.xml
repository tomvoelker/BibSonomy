<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sqlMap PUBLIC "-//iBATIS.com//DTD SQL Map 2.0//EN" "http://www.ibatis.com/dtd/sql-map-2.dtd">

<sqlMap namespace="Tag">
	<typeAlias alias="tag" type="org.bibsonomy.model.Tag" />
	<typeAlias alias="tagTagBatchParam" type="org.bibsonomy.database.params.beans.TagTagBatchParam" />

	<resultMap id="tags" class="tag">
		<result property="id"    column="tag_id"   javaType="java.lang.Integer" />
		<result property="name"  column="tag_name" javaType="java.lang.String" />
		<result property="stem"  column="tag_stem" javaType="java.lang.String" />
        <!-- FIXME globalcount or usercount? -->
		<result property="globalcount" column="tag_ctr"  javaType="java.lang.Integer" />
	</resultMap>

	<select id="getTagById" resultMap="tags" parameterClass="int">
		SELECT tag_id, tag_name, tag_stem, tag_ctr FROM tags WHERE tag_id = #id#
	</select>

	<select id="getTagByCount" resultMap="tags" parameterClass="tagParam">
		SELECT tag_id, tag_name, tag_stem, tag_ctr FROM tags WHERE tag_ctr = #count#
	</select>

	<!-- TODO: this is only a hack to provide tag-support. feel free to change it. -->
	<select id="getAllTags" resultMap="Common.tagWithCount" parameterClass="tagParam">
		SELECT tag_name, count(tag_name) AS tag_count FROM tas t GROUP BY t.tag_name LIMIT #limit# OFFSET #offset#
	</select>
	
	<!-- TODO to adapted-->
	<select id="getTagsByExpression" resultClass="string" parameterClass="tagParam">
		SELECT * FROM tags WHERE tag_name REGEXP '^regex' LIMIT #limit# OFFSET #offset#
	</select>

 	<select id="getTagsViewable" resultClass="string" parameterClass="tagParam">
		SELECT tag_name, count(tag_name) AS tag_count FROM tas t
		WHERE t.group = #groupType#
		GROUP BY t.tag_name LIMIT #limit# OFFSET #offset#
	</select>

	<!-- TODO: this is only a hack to provide tag-support. feel free to change it. -->	
	<select id="getTagsByUser" resultMap="Common.tagWithCount" parameterClass="tagParam">
		SELECT tag_name, count(tag_name) AS tag_count FROM tas t WHERE t.user_name = #requestedUserName#
		<include refid="getTagForUser"/> GROUP BY t.tag_name LIMIT #limit# OFFSET #offset#
	</select>

	<select id="getTagsByGroup" resultClass="string" parameterClass="tagParam">
		SELECT tag_name, count(tag_name) AS tag_count FROM 
		((SELECT tag_name
		  FROM tas t, groups g
		  WHERE g.group = #groupId# AND g.user_name=t.user_name
		  <include refid="lookinGroupsForTags"/>) 
		 UNION
		 (SELECT tag_name
		  FROM tas t, groups g, friends f
		  WHERE f.f_user_name = #userName# AND g.user_name = f.user_name
		        AND t.user_name = f.user_name AND g.group = #groupId# AND t.group = $groupType$)     
		 UNION
		 (SELECT tag_name
		  FROM tas t, groups g
		  WHERE t.user_name = #userName# AND g.user_name = t.user_name
		        AND g.group = #groupId#)) AS tagsalias
		GROUP BY tag_name LIMIT #limit# OFFSET #offset#
	</select>

    <!-- noch an TagParam anpassen für das Einfügen von Bookmark bzw Bibtex Objekten -->
	<insert id="insertTag" parameterClass="tag">
    	INSERT INTO tags (tag_name, tag_ctr)
    	VALUES (#name#,1)
    	ON DUPLICATE KEY UPDATE tag_ctr = tag_ctr+1
	</insert>

	<!-- FIXME: this looks weird
	<insert id="insertTagTag" parameterClass="tag">
		INSERT INTO tags (tag_name, tag_name, tag_ctr)
		VALUES (#name#, #name#, 1)
		ON DUPLICATE KEY UPDATE tag_ctr = tag_ctr+1
	</insert>
	-->
	
	<insert id="insertTagTagBatch" parameterClass="tagTagBatchParam">
		INSERT INTO tagtag_batch (content_id, tags, toinc) VALUES (#contentId#, #tagList#, #jobInteger#)
	</insert>
</sqlMap>