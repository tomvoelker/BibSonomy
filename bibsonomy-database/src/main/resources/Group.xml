<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sqlMap PUBLIC "-//iBATIS.com//DTD SQL Map 2.0//EN" "http://www.ibatis.com/dtd/sql-map-2.dtd">

<sqlMap namespace="Group">
	<!-- TODO: do we need the memberships here? -->
	<select id="getAllGroups" resultMap="GroupCommon.groupWithMembershipsAndReportings" parameterClass="groupParam">
		SELECT <include refid="basicColumns" />, <include refid="reportingColumns" />, u.user_realname, u.user_homepage, g.user_name, g.group_role, g.user_shared_documents, g.start_date
		FROM
			(SELECT * from groupids
				WHERE `group` > 2
					ORDER BY group_name
					LIMIT #limit# OFFSET #offset#) i 
		  JOIN group_memberships g USING (`group`)
		  JOIN user u ON (i.group_name = u.user_name)
		ORDER BY i.group_name
	</select>

	<select id="getAllOrganizationGroups" resultMap="GroupCommon.groupWithMembershipsAndReportings" parameterClass="groupParam">
		SELECT <include refid="basicColumns" />, <include refid="reportingColumns" />, u.user_realname, u.user_homepage, g.user_name, g.group_role, g.user_shared_documents, g.start_date
		FROM
		(SELECT * from groupids
		WHERE `group` > 2
		AND `organization` = 1
		ORDER BY group_name
		LIMIT #limit# OFFSET #offset#) i
		JOIN group_memberships g USING (`group`)
		JOIN user u ON (i.group_name = u.user_name)
		ORDER BY i.group_name
	</select>

	<select id="getPendingGroups" resultMap="GroupCommon.group" parameterClass="groupParam">
		SELECT <include refid="basicColumns" />, <include refid="requestColumns" />, <include refid="reportingColumns" />, u.user_realname, u.user_homepage
		FROM pending_groupids i 
		  JOIN pendingUser u ON (i.group_name = u.user_name)
		<dynamic prepend="WHERE">
			<isNotNull prepend="AND" property="userName">
				i.request_user_name = #userName# 
			</isNotNull>
		</dynamic>
		ORDER BY i.group_name
		LIMIT #limit# OFFSET #offset#
	</select>
	
	<select id="getPendingGroup" resultMap="GroupCommon.groupWithParent" parameterClass="groupParam">
		SELECT <include refid="basicColumns" />, <include refid="requestColumns" />, <include refid="reportingColumns" />, u.user_realname, u.user_homepage, <include refid="parentColumns" />
		FROM pending_groupids i 
		  JOIN pendingUser u ON (i.group_name = u.user_name)
		  LEFT JOIN groupids pt ON (i.parent = pt.group) <!-- join with parent -->
		  LEFT JOIN user upt ON (upt.user_name = pt.group_name)
		WHERE i.group_name = #requestedGroupName#
		<isNotEmpty prepend="AND" property="userName">
			i.request_user_name = #userName#
		</isNotEmpty>
	</select>

	<select id="getGroupWithMemberships" resultMap="GroupCommon.groupWithMembershipsAndReportingsAndParent" parameterClass="string">
		SELECT <include refid="basicColumns" />, <include refid="reportingColumns" />, u.user_realname, u.user_homepage, g.user_name, g.group_role, g.user_shared_documents, g.start_date, <include refid="parentColumns" />
		FROM groupids i 
		<!-- LEFT JOIN is necessary because groups are empty at the point of creation. -->
		  LEFT JOIN group_memberships g USING (`group`) 
		  LEFT JOIN user u ON (u.user_name = i.group_name)
		  LEFT JOIN groupids pt ON (i.parent = pt.group) <!-- join with parent -->
		  LEFT JOIN user upt ON (upt.user_name = pt.group_name)
		WHERE i.group_name = #groupname#
		  AND i.group > 2
		ORDER BY g.user_name
	</select>
	<!-- post -> tag Beziehung ansehen -->

	<select id="getGroupWithPermissions" resultMap="GroupCommon.groupWithPermissions" parameterClass="string">
		SELECT <include refid="basicColumns" />, p.permission
		FROM groupids i 
		  LEFT JOIN group_level_permission p USING (`group`)
		WHERE group_name = #groupname#
		  AND i.group > 2
	</select>
	
	<!-- TODO: merge with getGroupWithMembership using a dynamic query -->
	<select id="getGroupWithMembershipsAndPermissions" resultMap="GroupCommon.groupWithMembershipsAndReportingsAndPermissionsAndParent" parameterClass="string">
		SELECT <include refid="basicColumns" />, <include refid="reportingColumns" />, u.user_realname, u.user_homepage, g.user_name, g.group_role, g.user_shared_documents, g.start_date, p.permission, <include refid="parentColumns" />
		FROM groupids i 
		<!-- LEFT JOIN is necessary because groups are empty at the point of creation. -->
		  LEFT JOIN group_memberships g USING (`group`) 
		  LEFT JOIN user u ON (u.user_name = i.group_name) 
		  LEFT JOIN group_level_permission p USING (`group`)
		  LEFT JOIN groupids pt ON (i.parent = pt.group) <!-- join with parent -->
		  LEFT JOIN user upt ON (upt.user_name = pt.group_name)
		WHERE i.group_name = #groupname#
		  AND i.group > 2
		ORDER BY g.user_name
	</select>


	<select id="getPrivlevelForGroup" resultClass="Privlevel" parameterClass="int">
		SELECT privlevel FROM groupids WHERE `group` = #groupId#
	</select>

	<select id="getGroupsForUser" resultMap="GroupCommon.groupWithMembershipsAndReportingsAndPermissions" parameterClass="string">
		SELECT <include refid="basicColumns" />, <include refid="reportingColumns" />, u.user_realname, u.user_homepage, g.user_name, g.user_shared_documents, g.group_role, g.start_date, p.permission
		 FROM groupids i
		   LEFT JOIN group_memberships g USING (`group`)
		   LEFT JOIN user u ON (u.user_name = i.group_name)
		   LEFT JOIN group_level_permission p USING (`group`)
		 WHERE g.user_name = #userName#
		ORDER BY i.group_name
	</select>
	
	<select id="getSpecialGroupsForUser" resultMap="GroupCommon.groupWithMembershipsAndReportings" parameterClass="string">
		SELECT <include refid="basicColumns" />, <include refid="reportingColumns" />, "" AS user_realname, NULL AS user_homepage, #userName# AS user_name, FALSE AS user_shared_documents, 2 AS group_role, DATE('1970-01-01') AS start_date
		 FROM groupids i
		 WHERE i.group BETWEEN 0 AND 2
		ORDER BY i.group_name
	</select>

	<select id="getGroupsForContentId" resultMap="GroupCommon.group_basic" parameterClass="int">
		SELECT DISTINCT <include refid="basicColumns" />, FALSE as user_shared_documents
		  FROM groupids i JOIN grouptas t USING (`group`) 
		  WHERE t.content_id = #contentId# 
	</select>

	<!-- TODO: Does this need pending_group_memberships as well? -->
	<select id="getGroupIdsForUser" resultClass="int" parameterClass="string">
		SELECT `group` FROM group_memberships WHERE user_name = #userName#
	</select>

	<!-- TODO: What's that for?! -->
	<select id="getGroupIdByGroupNameAndUserName" resultClass="int" parameterClass="groupParam">
		SELECT g.group
		FROM groupids g <isNotNull property="requestedUserName" prepend=",">group_memberships i</isNotNull>
		WHERE g.group_name = #requestedGroupName#
		      <isNotNull property="requestedUserName" prepend="AND">
		        i.user_name = #requestedUserName#
		        AND i.group = g.group
		      </isNotNull>
	</select>

	<!--
	 	Selects the ids of all groups that are parents of the given group where the user is a member (by group_name).
	-->
	<select id="getParentGroupsWhereUserIsMember" resultClass="int" parameterClass="org.bibsonomy.database.params.group.GetParentGroupIdsRecursively">
		SELECT parent_group_id FROM `group_hierarchy` gh
		  JOIN `groupids` g ON (gh.child_group_id = g.group)
		  JOIN `group_memberships` gm ON (gm.group = gh.parent_group_id)
		WHERE g.group_name = #groupname# and gm.user_name = #username#
	</select>

	<select id="getTagSetsForGroup" resultMap="GroupCommon.tagsets" parameterClass="string">
		SELECT set_name, tag_name 
		FROM groupids i
		  JOIN group_tagsets s USING (`group`)
		WHERE i.group_name = #groupname#
	</select>
	
	<select id="getTagSetBySetNameAndGroup" resultMap="GroupCommon.tagsets" parameterClass="tagSetParam">
		SELECT set_name, tag_name from group_tagsets s
		WHERE s.group = #groupId#
		AND s.set_name = #setName#
	</select>

	<select id="getPresetTagsForGroup" resultMap="GroupCommon.presetTags" parameterClass="string">
		SELECT tag_name, group_name, `group`, description
		FROM group_preset_tags gpt
		WHERE gpt.group_name = #groupname#
	</select>
	
	<insert id="insertTagSet" parameterClass="tagSetParam">
		INSERT INTO group_tagsets (set_name, tag_name, `group`) VALUES (#setName#, #tagName#, #groupId#)
	</insert>

	<delete id="deleteTagSet" parameterClass="tagSetParam">
		DELETE FROM group_tagsets
		WHERE set_name = #setName# AND `group` = #groupId#
	</delete>

	<insert id="activateGroup" parameterClass="string">
		INSERT INTO groupids (group_name, `group`, `parent`, privlevel, allow_join, sharedDocuments, shortDescription, organization, internal_id)
		SELECT group_name, `group`, `parent`, privlevel, sharedDocuments, allow_join, shortDescription, organization, internal_id
		FROM pending_groupids 
		WHERE pending_groupids.group_name = #name#
	</insert>
	
	<delete id="deleteGroup" parameterClass="int">
		DELETE FROM groupids
		WHERE `group` = #groupId#
	</delete>
	
	<insert id="insertPendingGroup" parameterClass="group">
		INSERT INTO pending_groupids (group_name, `group`, `parent`, privlevel, allow_join, sharedDocuments, shortDescription, `organization`, `internal_id`, request_user_name, request_reason)
		VALUES (#name#, #groupId#, #parent.groupId#, #privlevel#, #allowJoin#, #sharedDocuments#, #description#, #organization#, #internalId#, #groupRequest.userName#, #groupRequest.reason#)
	</insert>

	<delete id="deletePendingGroup" parameterClass="string">
		DELETE FROM pending_groupids
		WHERE pending_groupids.group_name = #groupname#
	</delete>

	<insert id="addUserToGroup" parameterClass="groupParam">
		INSERT INTO group_memberships (user_name, `group`, defaultgroup, group_role, user_shared_documents)
		VALUES (#membership.user.name#, #groupId#, #groupId#, #membership.groupRole#, #membership.userSharedDocuments#)
	</insert>

	<delete id="removeUserFromGroup" parameterClass="groupParam">
		DELETE FROM group_memberships
		WHERE `group` = #groupId# AND user_name = #userName#
	</delete>

	<delete id="removeAllUserFromGroup" parameterClass="int">
		DELETE FROM group_memberships
		WHERE `group` = #groupId#
	</delete>

	<update id="updateGroupSettings" parameterClass="group">
		UPDATE groupids 
		SET privlevel=#privlevel#, sharedDocuments=#sharedDocuments#, allow_join=#allowJoin#, shortDescription=#description#, organization=#organization#
		WHERE `group` = #groupId#
	</update>
	
	<update id="updateGroupPublicationReportingSettings" parameterClass="group">
		UPDATE groupids
		SET	publ_reporting_mail = #publicationReportingSettings.reportingMailAddress#,
			publ_reporting_mail_template = #publicationReportingSettings.reportingMailTemplate#,
			publ_reporting_external_url = #publicationReportingSettings.externalReportingUrl#
		WHERE group_name = #name#
	</update>

	<update id="updateGroupRole" parameterClass="groupParam">
		UPDATE group_memberships 
		SET group_role=#membership.groupRole.role#
		WHERE `group` = #groupId# AND `user_name` = #membership.user.name#
	</update>
	
	<select id="countPerRole" resultClass="Integer" parameterClass="groupParam">
		SELECT COUNT(*)
		FROM group_memberships
		WHERE group_memberships.group_role = #membership.groupRole.role# AND group_memberships.group = #groupId#;
	</select>
	
	<select id="getGroupMembershipForUserInGroup" resultMap="GroupCommon.groupMembership" parameterClass="groupParam">
		SELECT ms.group_role, ms.user_name, u.user_realname, u.user_homepage, ms.user_shared_documents, ms.start_date 
		FROM group_memberships ms
		  JOIN user u ON (u.user_name = ms.user_name)
		WHERE ms.user_name = #userName# AND ms.`group` = #groupId#;
	</select>
	
	<!-- PENDING MEMBERSHIPS -->
	<select id="getPendingMembershipForUserInGroup" resultMap="GroupCommon.groupMembership" parameterClass="groupParam">
		SELECT ms.group_role, ms.user_name, ms.user_shared_documents, ms.start_date 
		FROM pending_group_memberships ms
		  JOIN groupids g USING (`group`)
		WHERE ms.user_name = #userName# AND g.group_name = #requestedGroupName#;
	</select>
	
	<insert id="addPendingMembership" parameterClass="groupParam">
		INSERT INTO pending_group_memberships (user_name, `group`, user_shared_documents, defaultgroup, `group_role`)
		VALUES (#membership.user.name#, #groupId#, #membership.userSharedDocuments#, #groupId#, #membership.groupRole.role#)
	</insert>

	<delete id="removePendingMembership" parameterClass="groupParam">
		DELETE FROM pending_group_memberships
		WHERE `group` = #groupId# AND user_name = #membership.user.name#
	</delete>
	
	<select id="getPendingMembershipsForGroup" resultMap="GroupCommon.groupWithMemberships" parameterClass="string">
		SELECT <include refid="basicColumns" />, u.user_realname, u.user_homepage, g.user_name, g.group_role, g.user_shared_documents, g.start_date
		FROM groupids i 
		  JOIN pending_group_memberships g USING (`group`) 
		  LEFT JOIN user u ON (u.user_name = i.group_name) 
		WHERE group_name = #groupname#
		  AND i.group > 2
	</select>
	
	<select id="getPendingMembershipsForUser" resultMap="GroupCommon.groupWithMemberships" parameterClass="string">
		SELECT <include refid="basicColumns" />, u.user_realname, u.user_homepage, g.user_name, g.user_shared_documents, g.group_role, g.start_date
		 FROM groupids i
		   LEFT JOIN pending_group_memberships g USING (`group`)
		   LEFT JOIN user u ON (u.user_name = i.group_name)
		 WHERE g.user_name = #userName# AND g.group_role != 2
	</select>
	
	<select id="getGroupMemberHistoryCount" resultClass="int">
		SELECT COUNT(*) FROM log_group_memberships
	</select>
	
	<insert id="insertGroupLevelPermission" parameterClass="groupParam">
		INSERT INTO group_level_permission (`group`, permission, granted_by)
		VALUES (#groupId#, #groupLevelPermission#, #grantedByUser#)
	</insert>

	<delete id="deleteGroupLevelPermission" parameterClass="groupParam">
		DELETE FROM group_level_permission
		WHERE `group` = #groupId#
		  AND `permission` = #groupLevelPermission#
	</delete>

	<select id="getSubgroupsFor" resultMap="GroupCommon.group_extended_with_parent" parameterClass="int">
		SELECT <include refid="basicColumns" />, u.user_realname, u.user_homepage, <include refid="parentColumns" />
			FROM groupids i
				<!-- LEFT JOIN is necessary because groups are empty at the point of creation. -->
				LEFT JOIN user u ON (u.user_name = i.group_name)
				LEFT JOIN groupids pt ON (i.parent = pt.group) <!-- join with parent -->
				LEFT JOIN user upt ON (upt.user_name = pt.group_name)
			WHERE i.parent = #groupId#
			ORDER BY i.group_name
	</select>


	<!--
	 	Efficiently selects all transitive subgroups for a group, by leveraging the group_hierarchy table.
	 -->
	<select id="getSubgroupsTransitively" resultMap="GroupCommon.group_extended_with_parent" parameterClass="list">
		SELECT <include refid="basicColumns" />, u.user_realname, u.user_homepage, <include refid="parentColumns" />
			FROM group_hierarchy gh
			LEFT JOIN groupids i ON (gh.parent_group_id = i.group)
			LEFT JOIN user u ON (u.user_name = i.group_name)
			LEFT JOIN groupids pt ON (i.parent = pt.group)
			LEFT JOIN user upt ON (upt.user_name = pt.group_name)
		WHERE gh.child_group_id IN
		<iterate open="(" close=")" conjunction=",">
			#[]#
		</iterate>
		ORDER BY i.group_name
	</select>

	<select id="getSubgroupIdsTransitively" resultClass="int" parameterClass="list">
		SELECT DISTINCT gh.child_group_id FROM group_hierarchy gh WHERE gh.parent_group_id IN
			<iterate open="(" close=")" conjunction=",">
				#[]#
			</iterate>
	</select>

	<select id="getGroupByInternalId" resultMap="GroupCommon.groupWithMembershipsAndReportings" parameterClass="string">
		SELECT <include refid="basicColumns" />, <include refid="reportingColumns" />, u.user_realname, u.user_homepage, g.user_name, g.group_role, g.user_shared_documents, g.start_date
			FROM groupids i
				JOIN group_memberships g USING (`group`)
				JOIN user u ON (i.group_name = u.user_name)
			WHERE i.internal_id = #internalId#
	</select>

	<!--
	 	Selects the ids of all groups that are parents of the given group where the user is a member (by group_name).
	-->
	<insert id="insertParentRelations" parameterClass="org.bibsonomy.database.params.group.InsertParentRelations">
		INSERT INTO `group_hierarchy`
		  SELECT #childGroupId#, parent_group_id FROM `group_hierarchy` gh
		    WHERE gh.child_group_id = #parentGroupId#
		  UNION
		  SELECT #childGroupId#, #parentGroupId#
	</insert>
</sqlMap>
