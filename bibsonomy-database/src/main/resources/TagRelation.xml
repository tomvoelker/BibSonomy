<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sqlMap PUBLIC "-//iBATIS.com//DTD SQL Map 2.0//EN" "http://www.ibatis.com/dtd/sql-map-2.dtd">

<sqlMap namespace="TagRelation">
	<insert id="insertTagRelationIfNotPresent" parameterClass="tagRelationParam">
		INSERT INTO tagtagrelations (relationID, lower, upper, date_of_create,
		user_name)
		SELECT value+1, #lowerTagName#, #upperTagName#,
		#creationDate#, #ownerUserName# FROM ids WHERE name = 2
	</insert>

	<delete id="deleteTagRelation" parameterClass="tagRelationParam">
		DELETE FROM
		tagtagrelations WHERE lower=#lowerTagName# AND upper=#upperTagName#
		AND user_name=#ownerUserName#
	</delete>

	<delete id="deleteConcept" parameterClass="tagRelationParam">
		DELETE FROM
		tagtagrelations WHERE upper=#upperTagName# AND
		user_name=#ownerUserName#
	</delete>

	<!-- the resultMap needs the column subTagCount whose value is always 1, since a 
		user cannot	have the same relation twice -->
	<select id="getPickedConceptsForUser" parameterClass="String"
		resultMap="TagCommon.tagWithSubtags">
		SELECT upper AS tag_name, 
			lower AS subTag, 
			'1' AS subTagCount
		FROM tagtagrelations
		WHERE user_name=#userName#
			AND picked=true 
		GROUP BY upper,
			lower
		ORDER BY LCASE(upper),
			LCASE(lower);
	</select>

	<!-- the resultMap needs the column subTagCount whose value is always 1, since a 
		user cannot	have the same relation twice -->
	<select id="getAllConceptsForUser" parameterClass="tagRelationParam"
		resultMap="TagCommon.tagWithSubtags">
		SELECT tagCount.upper AS tag_name, 
			r.lower AS subTag, 
			'1' AS subTagCount
		FROM tagtagrelations r, 
		(SELECT upper AS upper 
			FROM tagtagrelations r
			WHERE user_name=#requestedUserName#
			GROUP BY upper
			ORDER BY LCASE(upper) 
				LIMIT #limit#
				OFFSET #offset#
		) AS tagCount
		WHERE user_name=#requestedUserName# 
			AND LCASE(tagCount.upper)=LCASE(r.upper)
		GROUP BY LCASE(r.upper), LCASE(r.lower)
		ORDER BY tagCount.upper COLLATE utf8_unicode_ci,
			LCASE(r.lower) COLLATE utf8_unicode_ci
	</select>

	<!-- the resultMap needs the column subTagCount whose value is always 1, since a 
		user cannot	have the same relation twice -->
	<select id="getConceptForUser" parameterClass="tagRelationParam"
		resultMap="TagCommon.tagWithSubtags">
		SELECT upper AS tag_name, 
			lower AS subTag,
			'1' as subTagCount
		FROM tagtagrelations
		WHERE LCASE(upper)=LCASE(#upperTagName#)
			AND user_name=#ownerUserName#
		GROUP BY LCASE(lower)
		ORDER BY LCASE(lower)
	</select>

	
	<select id="getAllConcepts" resultMap="TagCommon.tagWithSubtagsAndUserCount">
		SELECT tagCount.upper AS tag_name, 
			LCASE(r.lower) AS subTag, 
			tagCount.usercount AS user_count, 
			COUNT(r.lower) AS subTagCount
		FROM tagtagrelations r JOIN user u USING(user_name), 
			(SELECT LCASE(upper) AS upper, COUNT(DISTINCT user_name) AS usercount, 
			COUNT(LCASE(upper) COLLATE utf8_unicode_ci) AS count
			FROM tagtagrelations r JOIN user u USING (user_name)
			WHERE u.spammer = 0
			GROUP BY LCASE(upper) COLLATE utf8_unicode_ci 
			ORDER BY usercount DESC, count DESC LIMIT 50
		) AS tagCount
		WHERE tagCount.upper=LCASE(r.upper)
			AND u.spammer = 0
		GROUP BY tagCount.upper, 
			LCASE(r.lower)
		ORDER BY tagCount.upper COLLATE utf8_unicode_ci,
			LCASE(r.lower) COLLATE utf8_unicode_ci
	</select>

	<select id="getGlobalConceptByName" parameterClass="String"
		resultMap="TagCommon.tagWithSubtags">
		SELECT LCASE(upper) AS tag_name, 
			lower AS subTag,
			COUNT(DISTINCT user_name) AS subTagCount
		FROM tagtagrelations JOIN user u USING(user_name)
		WHERE LCASE(upper) = LCASE(#conceptName#)
			AND u.spammer = 0
		GROUP BY LCASE(upper), LCASE(lower)
		ORDER BY LCASE(upper) COLLATE utf8_unicode_ci, 
			LCASE(lower) COLLATE utf8_unicode_ci;
	</select>

	<select id="getRelationID" parameterClass="tagRelationParam"
		resultClass="string">
		SELECT relationID FROM tagtagrelations where user_name =
		#ownerUserName# and lower = #lowerTagName# and upper = #upperTagName#
	</select>
	
	<update id="pickConcept" parameterClass="tagRelationParam">
		UPDATE tagtagrelations SET picked = true
		WHERE user_name = #ownerUserName# AND upper = #upperTagName#
	</update>
	
	<update id="unpickConcept" parameterClass="tagRelationParam">
		UPDATE tagtagrelations SET picked = false
		WHERE user_name = #ownerUserName# AND upper = #upperTagName#
	</update>
	
	<update id="pickAllConcepts" parameterClass="String">
		UPDATE tagtagrelations SET picked = true
		WHERE user_name = #ownerUserName#
	</update>
	
	<update id="unpickAllConcepts" parameterClass="String">
		UPDATE tagtagrelations SET picked = false
		WHERE user_name = #ownerUserName#
	</update>
</sqlMap>