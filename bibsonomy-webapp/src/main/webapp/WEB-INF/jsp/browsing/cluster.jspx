<?xml version="1.0" ?>
<jsp:root version="2.0"
	xmlns="http://www.w3.org/1999/xhtml"
	xmlns:jsp="http://java.sun.com/JSP/Page"
	xmlns:c="http://java.sun.com/jsp/jstl/core"
	xmlns:fmt="http://java.sun.com/jsp/jstl/fmt"
	xmlns:layout="urn:jsptagdir:/WEB-INF/tags/layout"
	xmlns:tags="urn:jsptagdir:/WEB-INF/tags/tags"
	xmlns:users="urn:jsptagdir:/WEB-INF/tags/users"
	xmlns:fn="http://java.sun.com/jsp/jstl/functions"
	xmlns:mtl="urn:jsptld:/WEB-INF/taglibs/mytaglib.tld">
	
	<jsp:directive.page contentType="text/html; charset=UTF-8" language="java" pageEncoding="UTF-8" session="true" />
	
	<layout:clusterLayout pageTitle="${command.pageTitle}" command="${command}" requPath="${requPath}">
	
		<jsp:attribute name="heading">
			<a rel="path_menu" href="#"><img alt="" src="${resdir}/image/box_arrow.png"/>${mtl:ch('nbsp')}<fmt:message key="navi.cluster"/></a> ::
  			
		   <!--+
		       | ajax content loader call back functions
		       +-->
           <script type="text/javascript">
           	  var numberOfClusters = ${command.numberOfClusters};
           	  var clusterSettings;
           	  var clusterResources;
           	  var numberOfPosts = 25;
              //<mtl:cdata>
              <![CDATA[
                  /**
                   * count number of clusters (deprecated)
                   */
				  function countCluster() {
				     var clusters = document.getElementById("clusterSettings");
				     var elements = clusters.getElementsByTagName("div");

				     numberOfClusters = 0;
					 for(i = 0; i < elements.length; i++) {
						 if( elements[i].id.startsWith("slider") ) {
						    numberOfClusters++;
						 }
					 }
				  }

                  /**
                   * called, when new resources arrived
                   */
                  function loadContentCallback(response, status, xhr) {
                  }

                  /**
                   * called, when new settings were received
                   */
                  function loadSettingsCallback(response, status, xhr) {
                     function createContext(idx) {
                    	id = idx;
                    	return {
                        	value: 50,
                    		change: function(event, ui) { changeClusterWeight(id, ui.value) }
                    	}
                     }

                     // count number of clusters
					 // countCluster();

                   	 // initialize sliders for each cluster
                     for( i=0; i<numberOfClusters; i++ ) {
                   	    var sliderName = "#slider"+i;
                        $(document).ready(function() {
                  	       $(sliderName).slider(createContext(i));
                  	    });
                     }
                  }
                  

                  /**
                   * reload resources
                   */
                  function reloadContent() {
                      // build query parameters
                      var queryParams = "";
                      for( i=0; i<numberOfClusters; i++ ) {
                    	  queryParams += "clusters["+i+"].clusterID="+clusterSettings.clusters[i].clusterID;
                    	  queryParams += "&clusters["+i+"].weight="+clusterSettings.clusters[i].weight;
                    	  if( i<numberOfClusters-1 ) {
                        	  queryParams += "&";
                    	  }
                      }

                	  //$('#outer').load('/bibsonomy-community-servlet/queryResources?'+queryParams, function(response, status, xhr) {loadContentCallback(response, status, xhr)});
					  $.getJSON('/bibsonomy-community-servlet/queryResources?'+queryParams+'&format=json', function(data) {
                    		clusterResources = data;
                    		updateContent();
                	  });
                  };

                  /**
                   * re-rank given cluster resources according to user settings
                   */
				  function updateContent() {
					  //readPosts(clusterResources);
      				  //rankPostsByRandom(clusterResources);
      				  rankPostsByWeight(clusterResources);
          			  var bt = btTemplate.expand(bibTexEntries);
        			  var bm = bmTemplate.expand(bookmarkEntries);
          			  document.getElementById("bmEntries").innerHTML = bm;
          			  document.getElementById("btEntries").innerHTML = bt;
				  }
                  
                  /**
                   * adopt current cluster settings according to user input
                   */
                  function changeClusterWeight(i, value) {
                      clusterSettings.clusters[i].weight = value;
                      updateContent();
                  }

                  /** 
                   * fetch new cluster settings from server
                   */
                  function reloadSettings() {
                	  $('#clusterSettings').load('/bibsonomy-community-servlet/clusterSettings?format=html', function(response, status, xhr) {loadSettingsCallback(response, status, xhr)});
                	  $.getJSON('/bibsonomy-community-servlet/clusterSettings?format=json', function(data) {
                    	  clusterSettings = data;
                    	  var n = clusterSettings.clusters.length;
                		});
                  }
              ]]> 
             //</mtl:cdata>
          </script>
          <c:set var="jsonBibTexTemplate">
              <![CDATA[
   	      			{# This is a comment and will be removed from the output.}
   	      			{.section items}
   	      			  <div id="bibtexList" class="bookbox">
   	      			  <div class="bboxheader">
   	      			     <h2 class="listh">publications</h2>
   	      			  </div>
   	      			  <div class="kiste">
					  	<span class="actions">&nbsp;</span>
					  </div>   
   	      			  <ul id="bibtex">
   	      			     {.repeated section @}
   	      			     <li class="bm cluster{clusterPos|html-attr-value}">
	   	      			     <div class="bmtitle"><a href="/bibtex/{intraHash|html-attr-value}">{label}</a></div>
							 <div class="bmdesc">
							 	<span style="color: rgb(85, 85, 85);">
								 	{.section author}
								 	{.repeated section @}
								 		{@|html}
								 	{.end}
								 	{.or}
								 	{.end}
								</span>
								<em>{journal}</em>(<em>{year}</em>) 
							 </div>
							 <span class="bmmeta">
							 	<span class="bmtags">
							 		{.section tags}
							 		{.repeated section @}
							 		<a href="user/{user|html-attr-value}/{@|html-attr-value}">{@|html}</a>
							 		{.end}
							 		{.or}
							 		{.end}
							 	</span>
								by <a name="{user}" href="/user/{user|html-attr-value}">{user|html}</a>
							 </span>
							 <div class="bmfoot">
							    <span class="bmaction">
							    	<a>pick</a>|
									<a>edit</a>|
									<a>delete</a>|
									<a>BibTeX</a>
								</span>
							 </div>
   	      			     </li>
   	      			     {.end}
   	      			  </table>
   	      			  </div>
   	      			{.or}
   	      			  <p><em>(No page content matches)</em></p>
   	      			{.end}					
              ]]> 
		  </c:set>
          <c:set var="jsonBookmarkTemplate">
              <![CDATA[
   	      			{# This is a comment and will be removed from the output.}
   	      			{.section items}
   	      			  <div id="bibtexList" class="bookbox">
   	      			  <div class="bboxheader">
   	      			     <h2 class="listh">bookmarks</h2>
   	      			  </div>   
   	      			  <div class="kiste">
					  	<span class="actions">&nbsp;</span>
					  </div>   
   	      			  <ul id="bibtex">
   	      			     {.repeated section @}
   	      			     <li class="bm cluster{clusterPos|html-attr-value}">
	   	      			     <div class="bmtitle"><a href="/bibtex/{intraHash|html-attr-value}">{label}</a></div>
							 <div class="bmdesc">
							 	{description|html} 
							 </div>
							 <span class="bmmeta">
							 	<span class="bmtags">
							 		{.section tags}
							 		{.repeated section @}
							 		<a href="user/{user|html-attr-value}/{@|html-attr-value}">{@|html}</a>
							 		{.end}
							 		{.or}
							 		{.end}
							 	</span>
								by <a name="{user}" href="/user/{user|html-attr-value}">{user|html}</a>
							 </span>
							 <div class="bmfoot">
							    <span class="bmaction">
							    	<a>pick</a>|
									<a>edit</a>|
								</span>
							 </div>
   	      			     </li>
   	      			     {.end}
   	      			  </table>
   	      			  </div>
   	      			{.or}
   	      			  <p><em>(No page content matches)</em></p>
   	      			{.end}					
              ]]> 
		  </c:set>
          <script type="text/javascript">
          var projectHome = "${projectHome}";
          var jsonBibTexTemplate   = "${mtl:escapeJavaScript(jsonBibTexTemplate)}";
	      var jsonBookmarkTemplate = "${mtl:escapeJavaScript(jsonBookmarkTemplate)}";
	      var btTemplate = jsontemplate.Template(jsonBibTexTemplate);
 		  var bmTemplate = jsontemplate.Template(jsonBookmarkTemplate);
          var bibTexEntries = {};
          var bookmarkEntries = {};
          //<mtl:cdata>
          <![CDATA[
			  $(document).ready(function() {
      		  	//write();
   			  });

			  /**
			   * stores publications in global var bibTexEntries and bookmarks in bookmarkEntries
			   */
   			  function readPosts(posts) {
   	   			  clusters = posts.clusters;
				  bibTexEntries.items   = new Array();
				  bookmarkEntries.items = new Array();
				  
   	   			  for( i=0; i<clusters.length; i++ ) {
   	   	   			  clusterPos = clusters[i].clusterPos;
					  bibtex     = clusters[i].bibtex;
					  bookmarks  = clusters[i].bookmarks;
					  for( j=0; j<bookmarks.length; j++ ) {
						bookmarks[j].clusterPos = clusterPos;
   	   	   				bookmarkEntries.items.push(bookmarks[j]);
   	   	   			  };
					  for( j=0; j<bibtex.length; j++ ) {
						bibtex[j].clusterPos = clusterPos;  
   	   	   	   			if( bibtex[j].journal == undefined ) {
   	   	   	   	   			bibtex[j].journal = "";
   	   	   	   			}
   	   	   			    bibTexEntries.items.push(bibtex[j]);  
   	   	   			  }
   	   			  }
   			  }

				/**
				 * ensure that all required fields are defined
				 */
			    function normalizePost(post, clusterPos) {
			    	post.clusterPos = clusterPos;
	   	   	   		if( post.journal == undefined ) {
   	   	   	   			post.journal = "";
 	   	   	   		}
			    }
			    
			    /**
			     * display the most important resources
			     */
				function rankPostsByWeight(clusterResources) {
					function weightComparator(obj1, obj2) {
						return obj1.weight < obj2.weight ? 1 : (obj1.weight > obj2.weight ? -1 : 0)
					};
					
					function addPosts(arr1, arr2, clusterPos, weight) {
						for( i=0; i<arr2.length; i++ ) {
							normalizePost(arr2[i], clusterPos);
							arr2[i].weight = arr2[i].weight * weight;
							arr1.push(arr2[i]);
						}
					}
					
   	   				// init data structures
   	   				clusters = clusterResources.clusters;
					bibTexEntries.items   = new Array();
					bookmarkEntries.items = new Array();
   	   			  
   	   				// read in weights from the sliders
   	   				updateWeights();
   	   				normalizeWeights(clusterResources);

   	   				// sum up all weights for calculating sample size proportions
   	   				weightSum = 0;
   	   				for( i=0; i<numberOfClusters; i++ ) {
   	   	   				weightSum += clusterSettings.clusters[i].weight;
   	   				}

   	   				for( j=0; j<clusters.length; j++ ) {
 	   	   				cluster = clusters[j];

 	   	   				// determine number of posts to display
 	   	   	   			clusterPostCount     = Math.round(numberOfPosts * (clusterSettings.clusters[j].weight/weightSum));
 	   	   	   			clusterBibTexCount   = Math.min(clusterPostCount, cluster.bibtex.length);
 	   	   	   		    clusterBookmarkCount = Math.min(clusterPostCount, cluster.bookmarks.length);

 	   	   	   		    // sort resources by weight and copy the most important posts
 	   	   	   		    // bibtex
 	   	   	   		    cluster.bibtex.sort(weightComparator);
 	   	   	   		    addPosts(bibTexEntries.items, cluster.bibtex.slice(0, clusterBibTexCount), j.toString(), clusterSettings.clusters[j].weight);
 	   	   	   		    // bookmark
 	   	   	   		    cluster.bookmarks.sort(weightComparator);
 	   	   	   		    addPosts(bookmarkEntries.items, cluster.bookmarks.slice(0, clusterBookmarkCount), j.toString(), clusterSettings.clusters[j].weight);
   	   				}

   	   	   			// finally sort posts across clusters
   	   	   			bibTexEntries.items.sort(weightComparator);
   	   	   			bookmarkEntries.items.sort(weightComparator);
   				}

   			  /**
   			   * get a random sample of the posts
   			   */
   			  function rankPostsByRandom(clusterResources) {
   	   			  // init data structures
   	   			  clusters = clusterResources.clusters;
				  bibTexEntries.items   = new Array();
				  bookmarkEntries.items = new Array();
   	   			  
   	   			  // read in weights from the sliders
   	   			  updateWeights();

   	   			  // sum up all weights for calculating sample size proportions
   	   			  weightSum = 0;
   	   			  for( i=0; i<numberOfClusters; i++ ) {
   	   	   			  weightSum += clusterSettings.clusters[i].weight;
   	   			  }

   	   			  // draw a random sample from each cluster, sized
   	   			  // proportional to the user given weights
   	   			  for( i=0; i<clusters.length; i++ ) {
   	   	   			  cluster = clusters[i];
   	   	   			  // create random index sequence
   	   	   			  cluster.rndBibTexSeq   = new Array();
   	   	   			  cluster.rndBookmarkSeq = new Array();
   	   	   			  for( j=0; j<cluster.bookmarks.length; j++ ) {
   	   	   	   			  cluster.rndBookmarkSeq[j] = j;
   	   	   			  };
   	   	   			  for( j=0; j<cluster.bibtex.length; j++ ) {
   	   	   	   			  cluster.rndBibTexSeq[j] = j;
   	   	   			  };
   	   	   			  shuffleArray(cluster.rndBookmarkSeq);
   	   	   			  shuffleArray(cluster.rndBibTexSeq);

   	   	   			  // determine number of posts to sample
   	   	   			  clusterPostCount     = Math.round(numberOfPosts * (clusterSettings.clusters[i].weight/weightSum));
   	   	   			  clusterBibTexCount   = Math.min(clusterPostCount, cluster.bibtex.length);
   	   	   		      clusterBookmarkCount = Math.min(clusterPostCount, cluster.bookmarks.length);

   	   	   		      // create BibTex sample
   	   	   		      for( j=0; j<clusterBibTexCount; j++ ) {
   	   	   	   		      post = cluster.bibtex[cluster.rndBibTexSeq[j]];
   	   	   	   		      post.clusterPos = cluster.clusterPos;
     	   	   	   		  if( post.journal == undefined ) {
         	   	   	   		  post.journal = "";
       	   	   	   		  }
   	   	   	   		      bibTexEntries.items.push(post);
   	   	   		      }
   	   	   		      // create Bookmark sample
   	   	   		      for( j=0; j<clusterBookmarkCount; j++ ) {
   	   	   	   		      post = cluster.bookmarks[cluster.rndBookmarkSeq[j]];
   	   	   	   		      post.clusterPos = cluster.clusterPos;
   	   	   		 		  bookmarkEntries.items.push(post);
   	   	   		      }
   	   			  }
   	   			  // finally shuffle all posts
   	   			  shuffleArray(bibTexEntries.items);
   	   			  shuffleArray(bookmarkEntries.items);
   			  }
   			  function rankPostsByDate(json) {
   	   			  
   			  }

   			  	/**
   			  	 * normalizes cluster weights for better comparibility
   			  	 */
   				function normalizeWeights(clusterResources) {
     	   			  // init data structures
     	   			  clusters = clusterResources.clusters;

       	   			  for( var i=0; i<clusters.length; i++ ) {
       	   	   			  cluster = clusters[i];

       	   	   			  // determine max. weight
       	   	   			  var maxBibTexWeight   = 0;
       	   	   			  var maxBookmarkWeight = 0;
       	   	   			  for( var j=0; j<cluster.bibtex.length; j++ ) {
           	   	   			  if( clusters[i].bibtex[j].weight>maxBibTexWeight ) { 
           	   	   				maxBibTexWeight = clusters[i].bibtex[j].weight
           	   	   			  }
       	   	   			  }
       	   	   			  for( var j=0; j<cluster.bookmarks.length; j++ ) {
           	   	   			  if( clusters[i].bookmarks[j].weight>maxBookmarkWeight ) { 
               	   	   			  maxBookmarkWeight = clusters[i].bookmarks[j].weight
           	   	   			  }
       	   	   			  }

       	   	   			  // normalize weight
       	   	   			  if( maxBibTexWeight>0 ) {
       	   	   			  	for( var j=0; j<cluster.bibtex.length; j++ ) {
           	   	   			  	clusters[i].bibtex[j].weight = clusters[i].bibtex[j].weight/maxBibTexWeight
       	   	   			  	}
       	   	   			  };
       	   	   			  if( maxBookmarkWeight>0 ) {
           	   	   			  for( var j=0; j<cluster.bookmarks.length; j++ ) {
               	   	   			  clusters[i].bookmarks[j].weight = clusters[i].bookmarks[j].weight/maxBookmarkWeight
           	   	   			  }
       	   	   			  }
       	   			  }
     	   			  
   				}
   				
   			  function updateWeights() {
   				for( i=0; i<numberOfClusters; i++ ) {
                   	sliderName = "#slider"+i;
               	   	value = $(sliderName).slider( "option", "value" );
               		clusterSettings.clusters[i].weight = value;
                }
   			  }
   			  
   			function shuffleArray ( myArray ) {
   			  i = myArray.length;
   			  if ( i == 0 ) return false;
   			  while ( --i ) {
   			     var j = Math.floor( Math.random() * ( i + 1 ) );
   			     var tempi = myArray[i];
   			     var tempj = myArray[j];
   			     myArray[i] = tempj;
   			     myArray[j] = tempi;
   			   }
   			}

   			function write() {
       			var t = jsontemplate.Template(jsonBibTexTemplate);
       			var u = jsontemplate.Template(jsonBookmarkTemplate);
      			var test = {
				   "items" : [
				      {  
				         "type" : "Publication",
				         "id"   : "http://www.biblicious.org/bibtex/20214f2e7e3f71d81109dd70a7015e542/kurtjx",
				         "intraHash" : "0214f2e7e3f71d81109dd70a7015e542",
				         "label" : "Statistical mechanics of complex networks",
				         "user" : "kurtjx",
				         "description" : "",
				         "date" : "2008-04-11 06:29:02",
				         "count" : 0,
				         "tags" : [ "tag1", "tag2", "tag3"
				         ],
				         "pub-type": "article",
				         "journal": "Rev. Mod. Phys.","publisher":"American Physical Society",
				         "year": "2002", 
				         "url": "", 
				         
				         "author": [ 
				            "R\\'eka Albert","Albert-L\\'aszl\\'o Barab\\'asi"
				         ],
				         "volume": "74","number": "1","pages": "47--97",
				         "bibtexKey": "RevModPhys.74.47"
				      }

				   ]
				};
      			var json = {
      					"types" : {
				      "Bookmark" : {
				         "pluralLabel" : "Bookmarks"
				      },
				      "Publication" : {
				         "pluralLabel" : "Publications"
				      },
				      "Tag" : {
				         "pluralLabel" : "Tags"
				      }
				   },
				   
				   "properties" : {
				      "count" : {
				         "valueType" : "number"
				      },
				      "date" : {
				         "valueType" : "date"
				      },
				      "url" : {
				         "valueType" : "url"
				      },
				      "id" : {
				         "valueType" : "url"
				      },
				      "tags" : {
				         "valueType" : "item"
				      },
				      "user" : {
				         "valueType" : "item"
				      }      
				   },
				   
				   "items" : [
				      
				      {  
				         "type" : "Bookmark",
				         "id"   : "http://www.biblicious.org/url/ae206e8daf59b4566ed8abcedc548448/lisher",
				         "intraHash" : "ae206e8daf59b4566ed8abcedc548448",
				         "label" : "Dokumentation zu Yahoo Pipes",
				         "user" : "lisher",
				         "description" : "Umfassende Dokumentation inclusive Tutorials und Informationen über die einzelnen Module. Erklärt auch, was Pipes überhaupt sind. Ganz interessant und gut erklärt, allerdings für einen Anfänger ohne Grundlagenkenntnisse über Feeds etc. ein bisschen unübersichtlich",
				         "date" : "2007-11-02 11:56:43",
				         "count" : 0,
				         "tags" : [
				            "fhhdb07"
				         ],
				         "url" : "http://pipes.yahoo.com/pipes/docs"
				      },
				      {  
				         "type" : "Bookmark",
				         "id"   : "http://www.biblicious.org/url/dd0a62f05d0bb55c7a202ca7db7ad262/lisher",
				         "intraHash" : "dd0a62f05d0bb55c7a202ca7db7ad262",
				         "label" : "Yahoo Pipes, eine Einführung",
				         "user" : "lisher",
				         "description" : "Sehr hilfreich, gut für absolute Anfänger geeignet. Kleinschrittige Erklärungen helfen weiter. Viele Beispiele, außerdem wird ganz gut grundsätzlich erklärt, worum es geht.",
				         "date" : "2007-11-02 11:58:41",
				         "count" : 0,
				         "tags" : [
				            "fhhdb07"
				         ],
				         "url" : "http://guxx.de/2007/08/15/yahoo-pipes-eine-einfuhrung/"
				      },
				      {  
				         "type" : "Bookmark",
				         "id"   : "http://www.biblicious.org/url/4554bd47be4128109cb1ccb3aab0d6c3/lisher",
				         "intraHash" : "4554bd47be4128109cb1ccb3aab0d6c3",
				         "label" : "allegro-C: Software für Bibliotheken",
				         "user" : "lisher",
				         "description" : "Homepage von Allegro-C",
				         "date" : "2007-11-03 04:31:08",
				         "count" : 0,
				         "tags" : [
				            "allegro-c"
				         ],
				         "url" : "http://www.allegro-c.de/"
				      },
				      {  
				         "type" : "Bookmark",
				         "id"   : "http://www.biblicious.org/url/63616463333adc05d1196b0b8bfceb4c/lisher",
				         "intraHash" : "63616463333adc05d1196b0b8bfceb4c",
				         "label" : "Schulungsmaterial allegro-c",
				         "user" : "lisher",
				         "description" : "",
				         "date" : "2007-11-03 04:33:07",
				         "count" : 0,
				         "tags" : [
				            "allegro-c"
				         ],
				         "url" : "http://www.andreaswolfconsulting.de/allegro-schulungsmaterial.html"
				      },
				      {  
				         "type" : "Publication",
				         "id"   : "http://www.biblicious.org/bibtex/26a324ad689b027f1882a9fc98dca1410/kurtjx",
				         "intraHash" : "6a324ad689b027f1882a9fc98dca1410",
				         "label" : "Mixing patterns in networks",
				         "user" : "kurtjx",
				         "description" : "",
				         "date" : "2008-03-23 04:56:08",
				         "count" : 0,
				         "tags" : [
				            "assortativity"
				         ],
				         "pub-type": "article",
				         "journal": "Physical Review E",
				         "year": "2003", 
				         "url": "http://www.citebase.org/abstract?id=oai:arXiv.org:cond-mat/0209450", 
				         
				         "author": [ 
				            "M. E. J. Newman"
				         ],
				         "volume": "67","pages": "026126","abstract": "We study assortative mixing in networks, the tendency for vertices in networks to be connected to other vertices that are like or unlike them in some way. We consider mixing according to discrete characteristics such as language or race in social networks and scalar characteristics such as age. As a special example of the latter we consider mixing according to vertex degree, i.e., according to the number of connections vertices have to other vertices: do gregarious people tend to associate with other gregarious people? We propose a number of measures of assortative mixing appropriate to the various mixing types, and apply them to a variety of real-world networks, showing that assortative mixing is a pervasive phenomenon found in many networks. We also propose several models of assortatively mixed networks, both analytic ones based on generating function methods, and numerical ones based on Monte Carlo graph generation techniques. We use these models to probe the properties of networks as their level of assortativity is varied. In the particular case of mixing by degree, we find strong variation with assortativity in the connectivity of the network and in the resilience of the network to the removal of vertices.",
				         "bibtexKey": "newman-assort-2003"
				      },
				      {  
				         "type" : "Publication",
				         "id"   : "http://www.biblicious.org/bibtex/20214f2e7e3f71d81109dd70a7015e542/kurtjx",
				         "intraHash" : "0214f2e7e3f71d81109dd70a7015e542",
				         "label" : "Statistical mechanics of complex networks",
				         "user" : "kurtjx",
				         "description" : "",
				         "date" : "2008-04-11 06:29:02",
				         "count" : 0,
				         "tags" : [
				            "complexnets_survey"
				         ],
				         "pub-type": "article",
				         "journal": "Rev. Mod. Phys.","publisher":"American Physical Society",
				         "year": "2002", 
				         "url": "", 
				         
				         "author": [ 
				            "R\\'eka Albert","Albert-L\\'aszl\\'o Barab\\'asi"
				         ],
				         "volume": "74","number": "1","pages": "47--97",
				         "bibtexKey": "RevModPhys.74.47"
				      }

				   ]
				};
				readPosts(json);
      			var bm = u.expand(bookmarkEntries);
      			var bt = t.expand(bibTexEntries);
      			document.getElementById("bmEntries").innerHTML = bm;
      			document.getElementById("btEntries").innerHTML = bt;
    		  }
              ]]> 
              //</mtl:cdata>
           </script>
		</jsp:attribute>
		
		<jsp:attribute name="headerExt">
			<!--  style sheets for slidebars -->
			<link href="/bibsonomy-community-servlet/resources/css/ui-lightness/jquery-ui-1.8.1.custom.css" rel="stylesheet" type="text/css"/>

			<!--  coloring according to clustering -->
			<link href="/bibsonomy-community-servlet/resources/css/clusterViews.css" rel="stylesheet" type="text/css"/>
			
			<!--  script for slidebars -->
			<script type="text/javascript" src="/bibsonomy-community-servlet/resources/javascript/jquery-ui-1.8.1.custom.min.js">&amp;nbsp;</script>	

			<!--  script for json templates -->
			<script type="text/javascript" src="${resdir}/javascript/json-template.js">&amp;nbsp;</script>	
			
		</jsp:attribute>
		
		<jsp:attribute name="sidebar">
			<div id="clusterSettings"><c:out value=" "/></div>
			
			<ul id="sidebar">
				<li>
					<a onclick="reloadContent()">Update Resources</a>
				</li>
				<li>
					<a onclick="reloadSettings()">Update Settings</a>
				</li>
			</ul>

		</jsp:attribute>
		
		<jsp:attribute name="contentHeading">
			<div id="bmEntries">&amp;nbsp;</div>
			<div id="btEntries">&amp;nbsp;</div>
		</jsp:attribute>
	</layout:clusterLayout>

</jsp:root>