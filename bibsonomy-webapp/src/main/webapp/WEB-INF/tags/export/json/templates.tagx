<!--+
    | templates for rendering json objects to html
    | FIXME: this could be done nicely, if we had an effective solution for createing hash maps in jstl...
    +-->
<jsp:root version="2.0" xmlns:c="http://java.sun.com/jsp/jstl/core"
	xmlns:jsp="http://java.sun.com/JSP/Page"
	xmlns:mtl="urn:jsptld:/WEB-INF/taglibs/mytaglib.tld"
	xmlns:fn="http://java.sun.com/jsp/jstl/functions">

	<!--+ =============================================================== +
	    |                            Posts                                |
	    + =============================================================== +-->
	<!--+
	    | list of publications 
	    +-->
	<c:set var="jsonBibTexResourceList">
              <![CDATA[
   	      			{# This is a comment and will be removed from the output.}
   	      			{.section items}
   	      			  <div id="bibtexList" class="bookbox">
   	      			  <div class="bboxheader">
   	      			     <h2 class="listh">publications</h2>
   	      			  </div>
   	      			  <div class="kiste">
					  	<span class="actions">&nbsp;</span>
					  </div>   
   	      			  <ul id="bibtex">
   	      			     {.repeated section @}
   	      			     <li class="bm cluster{clusterPos|html-attr-value}">
	   	      			     <div class="bmtitle"><a href="/bibtex/{intraHash|html-attr-value}">{label}</a></div>
							 <div class="bmdesc">
							 	<span style="color: rgb(85, 85, 85);">
								 	{.section author}
								 	{.repeated section @}
								 		{@|html}
								 	{.end}
								 	{.or}
								 	{.end}
								</span>
								<em>{journal}</em>(<em>{year}</em>) 
							 </div>
							 <span class="bmmeta">
							 	<span class="bmtags">
							 		{.section tags}
							 		{.repeated section @}
							 		<a href="user/{user|html-attr-value}/{@|html-attr-value}">{@|html}</a>
							 		{.end}
							 		{.or}
							 		{.end}
							 	</span>
								by <a name="{user}" href="/user/{user|html-attr-value}">{user|html}</a>
							 </span>
							 <div class="bmfoot">
							    <span class="bmaction">
							    	<a>pick</a>|
									<a>edit</a>|
									<a>delete</a>|
									<a>BibTeX</a>
								</span>
							 </div>
   	      			     </li>
   	      			     {.end}
   	      			  </table>
   	      			  </div>
   	      			{.or}
   	      			  <p><em>(No page content matches)</em></p>
   	      			{.end}					
              ]]> 
		  </c:set>
          <c:set var="jsonBookmarkResourceList">
              <![CDATA[
   	      			{# This is a comment and will be removed from the output.}
   	      			{.section items}
   	      			  <div id="bibtexList" class="bookbox">
   	      			  <div class="bboxheader">
   	      			     <h2 class="listh">bookmarks</h2>
   	      			  </div>   
   	      			  <div class="kiste">
					  	<span class="actions">&nbsp;</span>
					  </div>   
   	      			  <ul id="bibtex">
   	      			     {.repeated section @}
   	      			     <li class="bm cluster{clusterPos|html-attr-value}">
	   	      			     <div class="bmtitle"><a href="/bibtex/{intraHash|html-attr-value}">{label}</a></div>
							 <div class="bmdesc">
							 	{description|html} 
							 </div>
							 <span class="bmmeta">
							 	<span class="bmtags">
							 		{.section tags}
							 		{.repeated section @}
							 		<a href="user/{user|html-attr-value}/{@|html-attr-value}">{@|html}</a>
							 		{.end}
							 		{.or}
							 		{.end}
							 	</span>
								by <a name="{user}" href="/user/{user|html-attr-value}">{user|html}</a>
							 </span>
							 <div class="bmfoot">
							    <span class="bmaction">
							    	<a>pick</a>|
									<a>edit</a>|
								</span>
							 </div>
   	      			     </li>
   	      			     {.end}
   	      			  </table>
   	      			  </div>
   	      			{.or}
   	      			  <p><em>(No page content matches)</em></p>
   	      			{.end}					    
	          ]]> 
		  </c:set>
    
    <!--+
	    | single BibTex entry 
	    +-->
	<c:set var="jsonBibTexEntry">
		<![CDATA[
			<li class="bm">
				<div class="bmtitle"><a href="/bibtex/{intraHash|html-attr-value}">{label}</a></div>
				<div class="bmdesc">
					<span style="color: rgb(85, 85, 85);">
						{.section author}
						{.repeated section @}
							{@|html}
						{.end}
						{.or}
						{.end}
					</span>
					(<em>{year}</em>) 
					</div>
					<span class="bmmeta">
						<span class="bmtags">
							{.section tags}
							{.repeated section @}
								<a href="user/{user|html-attr-value}/{@|html-attr-value}">{@|html}</a>
							 {.end}
							 {.or}
							 {.end}
						</span>
						by <a name="{user}" href="/user/{user|html-attr-value}">{user|html}</a>
					</span>
					<div class="bmfoot">
						<span class="bmaction">
							<a>pick</a>|
							<a>edit</a>|
							<a>delete</a>|
							<a>BibTeX</a>
							</span>
					</div>
   	      		</li>
              ]]>
	</c:set>

	<!--+
	    | single Bookmark entry 
	    +-->
	<c:set var="jsonBookmarkEntry">
		<![CDATA[
			<li class="bm">
				<div class="bmtitle"><a href="/bibtex/{intraHash|html-attr-value}">{label}</a></div>
				<div class="bmdesc">
				 	{description|html} 
				</div>
				<span class="bmmeta">
				 	<span class="bmtags">
				 		{.section tags}
				 		{.repeated section @}
				 			<a href="user/{user|html-attr-value}/{@|html-attr-value}">{@|html}</a>
				 		{.end}
				 		{.or}
				 		{.end}
				 	</span>
					by <a name="{user}" href="/user/{user|html-attr-value}">{user|html}</a>
				</span>
				<div class="bmfoot">
					<span class="bmaction">
				    	<a>pick</a>|
						<a>edit</a>|
					</span>
				 </div>
			</li>
		]]>
	</c:set>
	
	<!--+
	    | a list of BibTex entries 
	    +-->
	<c:set var="jsonBibTexList">
		<![CDATA[
			<div id="bibtexList" class="bookbox">
	   			<ul id="bibtex">
	             	{.repeated section @}
    	         		{@|bibTexEntry}
   	          	{.end}
   	       	  	</ul>
			</div>
		]]>
	</c:set>

	<!--+
	    | a list of Bookmark entries 
	    +-->
	<c:set var="jsonBookmarkList">
		<![CDATA[
			<div id="bibtexList" class="bookbox">
	   			<ul id="bibtex">
	           		{.repeated section @}
    	         		{@|bookmarkEntry}
   	    	      	{.end}
				</ul>
			</div>
		]]>
	</c:set>
	
	<c:set var="jsonResourcesPreview">
		<![CDATA[
			{bookmarks|bookmarkList}
			{bibtex|bibTexList}
		]]>
	</c:set>
	

	<!--+ =============================================================== +
	    |                            Tags                                 |
	    + =============================================================== +-->
	<c:set var="jsonTagCloud">
		<![CDATA[
			<ul class="tagcloud">
            {.repeated section @}
            	<li class="{@|tagSize}">
	            	<a class="{@|tagSize}" 
			            style="font-size:{@|tagFontSize}%; padding-left:0.3em; padding-right:0.3em;" 
			            title="{globalcount|html-attr-value} posts" 
		    	        href="/tag/{name|html-attr-value}">{name|html}</a>
            	</li>
            {.end}
            </ul>
		]]>
	</c:set>
	
	<!--+ =============================================================== +
	    |                          Clusters                               |
	    + =============================================================== +-->
	<c:set var="jsonClusterSettings">
		<![CDATA[
			<h1>Selected Communities</h1><br/><br/>
			<ul>
			{.repeated section clusters}
				<li class="clusterSettings{clusterPos|html-attr-value}">
					<hr/>
					<div style="text-align: right;">
						<a onclick="resetClusterView();removeCluster({clusterID|html-attr-value})">
							<img  alt="switch cluster..." src="${command.communityBaseUrl}${resdir}/image/button_reload.png"/>
						</a>
					</div>
					<br/>
					{tags|tagCloud}
					<br/>
					<div id="slider{clusterPos|html-attr-value}"> </div>
				</li>
			{.end}
			</ul>
			<hr/>
		]]>
	</c:set>
	    
	<c:set var="jsonClusterOverview">
		<![CDATA[
			<h1>Communities</h1><br/>
			{.repeated section clusters}
				<hr/>
				{.section clusterID}
					{.if isClusterEnabled}
						<a onclick="resetClusterView();removeCluster({clusterID|html-attr-value})">[remove cluster]</a>
					{.or}
						<a onclick="addCluster({clusterID|html-attr-value},0.5)">[add cluster]</a>
					{.end}
				{.end}
				<br/>
				{tags|tagCloud}
				<center>
					<a onclick="$('#clusterResources{clusterPos|html-attr-value}').toggle();loadClusterResources('clusterResources{clusterPos|html-attr-value}', {clusterPos|html-attr-value});">Toggle Resources</a>
				</center>
				<div style="display:none;" id="clusterResources{clusterPos|html-attr-value}">
					<p class="centeredImage">
						<img  id="wait_clusterResources{clusterPos|html-attr-value}" alt="loading resources..." src="${command.communityBaseUrl}${resdir}/image/ajax-loader.gif"/>
					</p>
					{bookmarks|bookmarkList}
					{bibtex|bibTexList}
				</div>
			{.end}
			<hr/>
			<center>      
				{listView|listNavigation}
			</center>
		]]>
	</c:set>
	
	<!--+ =============================================================== +
	    |                        Navigation                               |
	    + =============================================================== +-->
	<c:set var="jsonListNavigation">
		<![CDATA[
			<a onclick="showPreviousClusters()">prev</a>
			|{@|listAnchors}
			<a onclick="showNextClusters()">next</a>		
		]]>
	</c:set>
	    
	<!--  script for json templates -->
	<script type="text/javascript" src="${resdir}/javascript/json-template.js">&amp;nbsp;</script>
			
	<script type="text/javascript">
		/** a map of all bibsonomy json template sources */
		var bibSonomyJsonTemplates = {
			//----------------------------------------------------------------
			// BibSonomy resource objects
			//----------------------------------------------------------------
			"bibTexEntry"         : "${mtl:quoteJSON(jsonBibTexEntry)}",
			"bookmarkEntry"       : "${mtl:quoteJSON(jsonBookmarkEntry)}",
			"bibTexList"          : "${mtl:quoteJSON(jsonBibTexList)}",
			"bookmarkList"        : "${mtl:quoteJSON(jsonBookmarkList)}",
			"bibTexResourceList"  : "${mtl:quoteJSON(jsonBibTexResourceList)}",
			"bookmarkResourceList": "${mtl:quoteJSON(jsonBookmarkResourceList)}",
			"resourcesPreview"    : "${mtl:quoteJSON(jsonResourcesPreview)}",
			
			//----------------------------------------------------------------
			// BibSonomy tag objects
			//----------------------------------------------------------------
			"tagCloud"        : "${mtl:quoteJSON(jsonTagCloud)}",
			
			//----------------------------------------------------------------
			// BibSonomy cluster views
			//----------------------------------------------------------------
			"listNavigation"  : "${mtl:quoteJSON(jsonListNavigation)}",
			"clusterSettings" : "${mtl:quoteJSON(jsonClusterSettings)}",
			"clusterOverview" : "${mtl:quoteJSON(jsonClusterOverview)}"
		};

		/** custom formatters */
		var bibSonomyJsonFormatters = {
			"listAnchors" : function(x){ return generateListAnchors(x) },
			"tagSize"     : function(x){ normalizeTags(clusterSettings.clusters); return getTagSize(x) },
			"tagFontSize" : function(x){ normalizeClusterSettings(clusterSettings.clusters); return getTagFontSize(x) },
			"html-attr-value" : function(x){ if( x!=undefined ) { return encodeURIComponent(x.toString()) } else { return "[[]]" } }
		};


        //<mtl:cdata>
        <![CDATA[
			/** a map of all compiled json templates */
        	var jsonTemplates = new Object();

        	// compile templates
			for (var template in bibSonomyJsonTemplates) {
	        	try {
	   				jsonTemplates[template] = jsontemplate.Template(bibSonomyJsonTemplates[template], {more_formatters: bibSonomyJsonformatters, more_predicates: bibSonomyJsonPredicates});
				} catch( e ) {
					alert("Error compiling template '"+template+"': " + e.message );
				}
			}

        	/**
        	 * predicates for implementing conditional matching in templates
        	 */
			function bibSonomyJsonPredicates(name) {
				// alert("Got predicate '"+name+"'");
				if( name == "exists" ) {
					return function(x) { return (typeof x !=undefined)};
				} else if( name == "isClusterEnabled" ) {
					return function(x) { return isClusterEnabled(x) };
				}
				return null;
			}
	        	
			/**
			 * function for enabling macro usage of different json templates
			 */
			function bibSonomyJsonformatters(name) {
	        	/** list of all standard templates */
	        	var stdTemplates = {
	               	"html"            : "",
	        		"html-attr-value" : "",
	        		"str"			  : "" 
	        	};

	        	// apply registered formatter if available
				if( (jsonTemplates[name] == undefined) && (bibSonomyJsonFormatters[name] == undefined) && (stdTemplates[name] == undefined) ) {
					alert("Unknown template " + name);
					return null;
				} else if( jsonTemplates[name] != undefined) {
					// alert("Handling template " + name);
					return function(x){return jsonTemplates[name].expand(x)};
				} else if( bibSonomyJsonFormatters[name] != undefined ) {
					// alert("Handling formatter " + name);
					return function(x) { return bibSonomyJsonFormatters[name](x) };
				}else {
					return null;
				}
			 }

			 /**
			  * function for rendering a json object to html applying the given json template
			  */
			  function renderJson(object, name) {
					if( jsonTemplates[name] == undefined ) {
						alert("I don't know the given template '" + name + "'");
						return null;
					} else {
						// alert("Handling template " + name);
						return jsonTemplates[name].expand(object);
					}
			  }
		]]> 
        //</mtl:cdata>
	</script>
	
	<!--+ =============================================================== +
	    |                  custom java script functions                   |
	    + =============================================================== +-->
	<script type="text/javascript">
	//<mtl:cdata>
        <![CDATA[
            /**
             * check if given cluster is already enabled by the logged in user
             */
			function isClusterEnabled(x) {
				if( clusterSettings == undefined ) {
					alert("No cluster settings loaded");
					return false;
				} else {
					for( var i=0; i<clusterSettings.clusters.length; i++ ) {
						if( clusterSettings.clusters[i].clusterID == x ) {
							return true;
						} 
					}
					return false;
				}
			}

			/**
			 * add given cluster to logged in user's settings
				<a href="bibsonomy-community-servlet/clusterSettings?action=ADDCLUSTERS&clusters[0]={clusterID|html-attr-value}">[add cluster]</a>
		     */
			function addCluster(clusterId, weight) {
				$.getJSON('/bibsonomy-community-servlet/clusterSettings?action=ADDCLUSTERS&clusters[0].clusterID='+clusterId+'&clusters[0].weight='+weight+'&format=json', function(data) {
           			clusterSettings = data;
    				reloadSettings(true);
    				showClusterPage();
       	  		});
		     }
		     
		     /**
			  * remove given cluster from logged in user's settings
		      */
			function removeCluster(clusterId) {
				$.getJSON('/bibsonomy-community-servlet/clusterSettings?action=REMOVECLUSTERS&clusters[0].clusterID='+clusterId+'&format=json', function(data) {
					clusterSettings = data;
					reloadSettings();
					showClusterPage();
	       	  	});
			}

			/**
			 * returns the css Class for a given tag
			 * @param tag the current Tag
			 * @return the css class for the tag
			 */
			function getTagSize(tag) {
				var tagCount    = tag.globalcount;
				var maxTagCount = tag.maxTagCount;
					
				/*
				 * catch incorrect values
				 */
				if (tagCount == 0 || maxTagCount == 0) return "tagtiny";

				var percentage = ((tagCount * 100) / maxTagCount);

				if (percentage < 25) {
					return  "tagtiny";
				} else if (percentage >= 25 && percentage < 50) {
					return  "tagnormal";
				} else if (percentage >= 50 && percentage < 75) {
					return  "taglarge";
				} else if (percentage >= 75) {
					return  "taghuge";
				}

				return "";
			}

			/**
			 * compute the resulting tag font size
			 */
			function getTagFontSize(tag) {
				var tagFrequency    = tag.globalcount;
				var tagMaxFrequency = tag.maxTagCount;
				/*
				 * we expect 0 < tagFrequency < tagMaxFrequency 
				 * and normalize f to 0 < f 100 as percentage of tagMaxFrequency
				 */
				f = 1.0*tagFrequency / tagMaxFrequency * 100;
				t = f > 100 ? 100 : f;
				t /= 5;
				t = Math.log(t) * 100;
				return (Math.round(t)<100) ? 100 : Math.round(t);		
			}	

			/**
			 * print list of direct links to pages
			 */	
			function generateListAnchors(listView) {
				var listNavigation = "";
				var cnt=1;
				for( var i=0; i<listView.total; i+=1.0*listView.limit ) {
					listNavigation +="<a onclick='showClusters("+i+","+listView.limit+");'>"+cnt+"</a>";
					if( i<listView.total ) {
						listNavigation +="&nbsp;|&nbsp;";
					}
					cnt++;
				}

				return listNavigation;
			} 
		]]> 
        //</mtl:cdata>
	</script>
</jsp:root>